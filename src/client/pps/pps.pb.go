// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pps/pps.proto

/*
	Package pps is a generated protocol buffer package.

	It is generated from these files:
		client/pps/pps.proto

	It has these top-level messages:
		Secret
		Transform
		Egress
		Job
		Service
		AtomInput
		CronInput
		Input
		JobInput
		ParallelismSpec
		InputFile
		Datum
		DatumInfo
		DatumInfos
		Aggregate
		ProcessStats
		AggregateProcessStats
		WorkerStatus
		ResourceSpec
		JobInfo
		Worker
		JobInfos
		Pipeline
		PipelineInput
		PipelineInfo
		PipelineInfos
		CreateJobRequest
		InspectJobRequest
		ListJobRequest
		DeleteJobRequest
		StopJobRequest
		GetLogsRequest
		LogMessage
		RestartDatumRequest
		InspectDatumRequest
		ListDatumRequest
		ListDatumResponse
		CreatePipelineRequest
		InspectPipelineRequest
		ListPipelineRequest
		DeletePipelineRequest
		StartPipelineRequest
		StopPipelineRequest
		RerunPipelineRequest
		GarbageCollectRequest
		GarbageCollectResponse
*/
package pps

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"
import google_protobuf1 "github.com/gogo/protobuf/types"
import google_protobuf2 "github.com/gogo/protobuf/types"
import _ "github.com/gogo/protobuf/gogoproto"
import pfs "github.com/pachyderm/pachyderm/src/client/pfs"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type JobState int32

const (
	JobState_JOB_STARTING JobState = 0
	JobState_JOB_RUNNING  JobState = 1
	JobState_JOB_FAILURE  JobState = 2
	JobState_JOB_SUCCESS  JobState = 3
	JobState_JOB_KILLED   JobState = 4
)

var JobState_name = map[int32]string{
	0: "JOB_STARTING",
	1: "JOB_RUNNING",
	2: "JOB_FAILURE",
	3: "JOB_SUCCESS",
	4: "JOB_KILLED",
}
var JobState_value = map[string]int32{
	"JOB_STARTING": 0,
	"JOB_RUNNING":  1,
	"JOB_FAILURE":  2,
	"JOB_SUCCESS":  3,
	"JOB_KILLED":   4,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}
func (JobState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{0} }

type DatumState int32

const (
	DatumState_FAILED   DatumState = 0
	DatumState_SUCCESS  DatumState = 1
	DatumState_SKIPPED  DatumState = 2
	DatumState_STARTING DatumState = 3
)

var DatumState_name = map[int32]string{
	0: "FAILED",
	1: "SUCCESS",
	2: "SKIPPED",
	3: "STARTING",
}
var DatumState_value = map[string]int32{
	"FAILED":   0,
	"SUCCESS":  1,
	"SKIPPED":  2,
	"STARTING": 3,
}

func (x DatumState) String() string {
	return proto.EnumName(DatumState_name, int32(x))
}
func (DatumState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{1} }

type WorkerState int32

const (
	WorkerState_POD_RUNNING WorkerState = 0
	WorkerState_POD_SUCCESS WorkerState = 1
	WorkerState_POD_FAILED  WorkerState = 2
)

var WorkerState_name = map[int32]string{
	0: "POD_RUNNING",
	1: "POD_SUCCESS",
	2: "POD_FAILED",
}
var WorkerState_value = map[string]int32{
	"POD_RUNNING": 0,
	"POD_SUCCESS": 1,
	"POD_FAILED":  2,
}

func (x WorkerState) String() string {
	return proto.EnumName(WorkerState_name, int32(x))
}
func (WorkerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{2} }

type PipelineState int32

const (
	// When the pipeline is not ready to be triggered by commits.
	// This happens when either 1) a pipeline has been created but not
	// yet picked up by a PPS server, or 2) the pipeline does not have
	// any inputs and is meant to be triggered manually
	PipelineState_PIPELINE_STARTING PipelineState = 0
	// After this pipeline is picked up by a pachd node.  This is the normal
	// state of a pipeline.
	PipelineState_PIPELINE_RUNNING PipelineState = 1
	// After some error caused runPipeline to exit, but before the
	// pipeline is re-run.  This is when the exponential backoff is
	// in effect.
	PipelineState_PIPELINE_RESTARTING PipelineState = 2
	// We have retried too many times and we have given up on this pipeline.
	PipelineState_PIPELINE_FAILURE PipelineState = 3
	// The pipeline has been explicitly paused by the user.
	PipelineState_PIPELINE_PAUSED PipelineState = 4
)

var PipelineState_name = map[int32]string{
	0: "PIPELINE_STARTING",
	1: "PIPELINE_RUNNING",
	2: "PIPELINE_RESTARTING",
	3: "PIPELINE_FAILURE",
	4: "PIPELINE_PAUSED",
}
var PipelineState_value = map[string]int32{
	"PIPELINE_STARTING":   0,
	"PIPELINE_RUNNING":    1,
	"PIPELINE_RESTARTING": 2,
	"PIPELINE_FAILURE":    3,
	"PIPELINE_PAUSED":     4,
}

func (x PipelineState) String() string {
	return proto.EnumName(PipelineState_name, int32(x))
}
func (PipelineState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPps, []int{3} }

type Secret struct {
	// Name must be the name of the secret in kubernetes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Key of the secret to load into env_var, this field only has meaning if EnvVar != "".
	Key       string `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
	MountPath string `protobuf:"bytes,2,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	EnvVar    string `protobuf:"bytes,3,opt,name=env_var,json=envVar,proto3" json:"env_var,omitempty"`
}

func (m *Secret) Reset()                    { *m = Secret{} }
func (m *Secret) String() string            { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()               {}
func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{0} }

func (m *Secret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Secret) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Secret) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *Secret) GetEnvVar() string {
	if m != nil {
		return m.EnvVar
	}
	return ""
}

type Transform struct {
	Image            string            `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Cmd              []string          `protobuf:"bytes,2,rep,name=cmd" json:"cmd,omitempty"`
	Env              map[string]string `protobuf:"bytes,3,rep,name=env" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Secrets          []*Secret         `protobuf:"bytes,4,rep,name=secrets" json:"secrets,omitempty"`
	ImagePullSecrets []string          `protobuf:"bytes,9,rep,name=image_pull_secrets,json=imagePullSecrets" json:"image_pull_secrets,omitempty"`
	Stdin            []string          `protobuf:"bytes,5,rep,name=stdin" json:"stdin,omitempty"`
	AcceptReturnCode []int64           `protobuf:"varint,6,rep,packed,name=accept_return_code,json=acceptReturnCode" json:"accept_return_code,omitempty"`
	Debug            bool              `protobuf:"varint,7,opt,name=debug,proto3" json:"debug,omitempty"`
}

func (m *Transform) Reset()                    { *m = Transform{} }
func (m *Transform) String() string            { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()               {}
func (*Transform) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{1} }

func (m *Transform) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Transform) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Transform) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Transform) GetSecrets() []*Secret {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *Transform) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *Transform) GetStdin() []string {
	if m != nil {
		return m.Stdin
	}
	return nil
}

func (m *Transform) GetAcceptReturnCode() []int64 {
	if m != nil {
		return m.AcceptReturnCode
	}
	return nil
}

func (m *Transform) GetDebug() bool {
	if m != nil {
		return m.Debug
	}
	return false
}

type Egress struct {
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
}

func (m *Egress) Reset()                    { *m = Egress{} }
func (m *Egress) String() string            { return proto.CompactTextString(m) }
func (*Egress) ProtoMessage()               {}
func (*Egress) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{2} }

func (m *Egress) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type Job struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{3} }

func (m *Job) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type Service struct {
	InternalPort int32 `protobuf:"varint,1,opt,name=internal_port,json=internalPort,proto3" json:"internal_port,omitempty"`
	ExternalPort int32 `protobuf:"varint,2,opt,name=external_port,json=externalPort,proto3" json:"external_port,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{4} }

func (m *Service) GetInternalPort() int32 {
	if m != nil {
		return m.InternalPort
	}
	return 0
}

func (m *Service) GetExternalPort() int32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

type AtomInput struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo       string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch     string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit     string `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob       string `protobuf:"bytes,5,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy       bool   `protobuf:"varint,6,opt,name=lazy,proto3" json:"lazy,omitempty"`
	FromCommit string `protobuf:"bytes,7,opt,name=from_commit,json=fromCommit,proto3" json:"from_commit,omitempty"`
}

func (m *AtomInput) Reset()                    { *m = AtomInput{} }
func (m *AtomInput) String() string            { return proto.CompactTextString(m) }
func (*AtomInput) ProtoMessage()               {}
func (*AtomInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{5} }

func (m *AtomInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AtomInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *AtomInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *AtomInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *AtomInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *AtomInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *AtomInput) GetFromCommit() string {
	if m != nil {
		return m.FromCommit
	}
	return ""
}

type CronInput struct {
	Name   string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string                      `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Commit string                      `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	Spec   string                      `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty"`
	Start  *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=start" json:"start,omitempty"`
}

func (m *CronInput) Reset()                    { *m = CronInput{} }
func (m *CronInput) String() string            { return proto.CompactTextString(m) }
func (*CronInput) ProtoMessage()               {}
func (*CronInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{6} }

func (m *CronInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CronInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *CronInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *CronInput) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *CronInput) GetStart() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

type Input struct {
	Atom  *AtomInput `protobuf:"bytes,1,opt,name=atom" json:"atom,omitempty"`
	Cross []*Input   `protobuf:"bytes,2,rep,name=cross" json:"cross,omitempty"`
	Union []*Input   `protobuf:"bytes,3,rep,name=union" json:"union,omitempty"`
	Cron  *CronInput `protobuf:"bytes,4,opt,name=cron" json:"cron,omitempty"`
}

func (m *Input) Reset()                    { *m = Input{} }
func (m *Input) String() string            { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()               {}
func (*Input) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{7} }

func (m *Input) GetAtom() *AtomInput {
	if m != nil {
		return m.Atom
	}
	return nil
}

func (m *Input) GetCross() []*Input {
	if m != nil {
		return m.Cross
	}
	return nil
}

func (m *Input) GetUnion() []*Input {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Input) GetCron() *CronInput {
	if m != nil {
		return m.Cron
	}
	return nil
}

type JobInput struct {
	Name   string      `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Commit *pfs.Commit `protobuf:"bytes,1,opt,name=commit" json:"commit,omitempty"`
	Glob   string      `protobuf:"bytes,2,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool        `protobuf:"varint,3,opt,name=lazy,proto3" json:"lazy,omitempty"`
}

func (m *JobInput) Reset()                    { *m = JobInput{} }
func (m *JobInput) String() string            { return proto.CompactTextString(m) }
func (*JobInput) ProtoMessage()               {}
func (*JobInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{8} }

func (m *JobInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobInput) GetCommit() *pfs.Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *JobInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *JobInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

type ParallelismSpec struct {
	// Starts the pipeline/job with a 'constant' workers, unless 'constant' is
	// zero. If 'constant' is zero (which is the zero value of ParallelismSpec),
	// then Pachyderm will choose the number of workers that is started,
	// (currently it chooses the number of workers in the cluster)
	Constant uint64 `protobuf:"varint,2,opt,name=constant,proto3" json:"constant,omitempty"`
	// Starts the pipeline/job with number of workers equal to 'coefficient' * N,
	// where N is the number of nodes in the kubernetes cluster.
	//
	// For example, if each Kubernetes node has four CPUs, you might set
	// 'coefficient' to four, so that there are four Pachyderm workers per
	// Kubernetes node, and each Pachyderm worker gets one CPU. If you want to
	// reserve half the nodes in your cluster for other tasks, you might set
	// 'coefficient' to 0.5.
	Coefficient float64 `protobuf:"fixed64,3,opt,name=coefficient,proto3" json:"coefficient,omitempty"`
}

func (m *ParallelismSpec) Reset()                    { *m = ParallelismSpec{} }
func (m *ParallelismSpec) String() string            { return proto.CompactTextString(m) }
func (*ParallelismSpec) ProtoMessage()               {}
func (*ParallelismSpec) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{9} }

func (m *ParallelismSpec) GetConstant() uint64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

func (m *ParallelismSpec) GetCoefficient() float64 {
	if m != nil {
		return m.Coefficient
	}
	return 0
}

type InputFile struct {
	// This file's absolute path within its pfs repo.
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// This file's hash
	Hash []byte `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *InputFile) Reset()                    { *m = InputFile{} }
func (m *InputFile) String() string            { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()               {}
func (*InputFile) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{10} }

func (m *InputFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *InputFile) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Datum struct {
	// ID is the hash computed from all the files
	ID  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Job *Job   `protobuf:"bytes,2,opt,name=job" json:"job,omitempty"`
}

func (m *Datum) Reset()                    { *m = Datum{} }
func (m *Datum) String() string            { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()               {}
func (*Datum) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{11} }

func (m *Datum) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Datum) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type DatumInfo struct {
	Datum    *Datum          `protobuf:"bytes,1,opt,name=datum" json:"datum,omitempty"`
	State    DatumState      `protobuf:"varint,2,opt,name=state,proto3,enum=pps.DatumState" json:"state,omitempty"`
	Stats    *ProcessStats   `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
	PfsState *pfs.File       `protobuf:"bytes,4,opt,name=pfs_state,json=pfsState" json:"pfs_state,omitempty"`
	Data     []*pfs.FileInfo `protobuf:"bytes,5,rep,name=data" json:"data,omitempty"`
}

func (m *DatumInfo) Reset()                    { *m = DatumInfo{} }
func (m *DatumInfo) String() string            { return proto.CompactTextString(m) }
func (*DatumInfo) ProtoMessage()               {}
func (*DatumInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{12} }

func (m *DatumInfo) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *DatumInfo) GetState() DatumState {
	if m != nil {
		return m.State
	}
	return DatumState_FAILED
}

func (m *DatumInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DatumInfo) GetPfsState() *pfs.File {
	if m != nil {
		return m.PfsState
	}
	return nil
}

func (m *DatumInfo) GetData() []*pfs.FileInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

type DatumInfos struct {
	DatumInfo []*DatumInfo `protobuf:"bytes,1,rep,name=datum_info,json=datumInfo" json:"datum_info,omitempty"`
}

func (m *DatumInfos) Reset()                    { *m = DatumInfos{} }
func (m *DatumInfos) String() string            { return proto.CompactTextString(m) }
func (*DatumInfos) ProtoMessage()               {}
func (*DatumInfos) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{13} }

func (m *DatumInfos) GetDatumInfo() []*DatumInfo {
	if m != nil {
		return m.DatumInfo
	}
	return nil
}

type Aggregate struct {
	Count                 int64   `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Mean                  float64 `protobuf:"fixed64,2,opt,name=mean,proto3" json:"mean,omitempty"`
	Stddev                float64 `protobuf:"fixed64,3,opt,name=stddev,proto3" json:"stddev,omitempty"`
	FifthPercentile       float64 `protobuf:"fixed64,4,opt,name=fifth_percentile,json=fifthPercentile,proto3" json:"fifth_percentile,omitempty"`
	NinetyFifthPercentile float64 `protobuf:"fixed64,5,opt,name=ninety_fifth_percentile,json=ninetyFifthPercentile,proto3" json:"ninety_fifth_percentile,omitempty"`
}

func (m *Aggregate) Reset()                    { *m = Aggregate{} }
func (m *Aggregate) String() string            { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()               {}
func (*Aggregate) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{14} }

func (m *Aggregate) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Aggregate) GetMean() float64 {
	if m != nil {
		return m.Mean
	}
	return 0
}

func (m *Aggregate) GetStddev() float64 {
	if m != nil {
		return m.Stddev
	}
	return 0
}

func (m *Aggregate) GetFifthPercentile() float64 {
	if m != nil {
		return m.FifthPercentile
	}
	return 0
}

func (m *Aggregate) GetNinetyFifthPercentile() float64 {
	if m != nil {
		return m.NinetyFifthPercentile
	}
	return 0
}

type ProcessStats struct {
	DownloadTime  *google_protobuf2.Duration `protobuf:"bytes,1,opt,name=download_time,json=downloadTime" json:"download_time,omitempty"`
	ProcessTime   *google_protobuf2.Duration `protobuf:"bytes,2,opt,name=process_time,json=processTime" json:"process_time,omitempty"`
	UploadTime    *google_protobuf2.Duration `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime" json:"upload_time,omitempty"`
	DownloadBytes uint64                     `protobuf:"varint,4,opt,name=download_bytes,json=downloadBytes,proto3" json:"download_bytes,omitempty"`
	UploadBytes   uint64                     `protobuf:"varint,5,opt,name=upload_bytes,json=uploadBytes,proto3" json:"upload_bytes,omitempty"`
}

func (m *ProcessStats) Reset()                    { *m = ProcessStats{} }
func (m *ProcessStats) String() string            { return proto.CompactTextString(m) }
func (*ProcessStats) ProtoMessage()               {}
func (*ProcessStats) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{15} }

func (m *ProcessStats) GetDownloadTime() *google_protobuf2.Duration {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *ProcessStats) GetProcessTime() *google_protobuf2.Duration {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *ProcessStats) GetUploadTime() *google_protobuf2.Duration {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *ProcessStats) GetDownloadBytes() uint64 {
	if m != nil {
		return m.DownloadBytes
	}
	return 0
}

func (m *ProcessStats) GetUploadBytes() uint64 {
	if m != nil {
		return m.UploadBytes
	}
	return 0
}

type AggregateProcessStats struct {
	DownloadTime  *Aggregate `protobuf:"bytes,1,opt,name=download_time,json=downloadTime" json:"download_time,omitempty"`
	ProcessTime   *Aggregate `protobuf:"bytes,2,opt,name=process_time,json=processTime" json:"process_time,omitempty"`
	UploadTime    *Aggregate `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime" json:"upload_time,omitempty"`
	DownloadBytes *Aggregate `protobuf:"bytes,4,opt,name=download_bytes,json=downloadBytes" json:"download_bytes,omitempty"`
	UploadBytes   *Aggregate `protobuf:"bytes,5,opt,name=upload_bytes,json=uploadBytes" json:"upload_bytes,omitempty"`
}

func (m *AggregateProcessStats) Reset()                    { *m = AggregateProcessStats{} }
func (m *AggregateProcessStats) String() string            { return proto.CompactTextString(m) }
func (*AggregateProcessStats) ProtoMessage()               {}
func (*AggregateProcessStats) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{16} }

func (m *AggregateProcessStats) GetDownloadTime() *Aggregate {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetProcessTime() *Aggregate {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadTime() *Aggregate {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetDownloadBytes() *Aggregate {
	if m != nil {
		return m.DownloadBytes
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadBytes() *Aggregate {
	if m != nil {
		return m.UploadBytes
	}
	return nil
}

type WorkerStatus struct {
	WorkerID string       `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	JobID    string       `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Data     []*InputFile `protobuf:"bytes,3,rep,name=data" json:"data,omitempty"`
	// Started is the time processing on the current datum began.
	Started   *google_protobuf1.Timestamp `protobuf:"bytes,4,opt,name=started" json:"started,omitempty"`
	Stats     *ProcessStats               `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
	QueueSize int64                       `protobuf:"varint,6,opt,name=queue_size,json=queueSize,proto3" json:"queue_size,omitempty"`
}

func (m *WorkerStatus) Reset()                    { *m = WorkerStatus{} }
func (m *WorkerStatus) String() string            { return proto.CompactTextString(m) }
func (*WorkerStatus) ProtoMessage()               {}
func (*WorkerStatus) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{17} }

func (m *WorkerStatus) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *WorkerStatus) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *WorkerStatus) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *WorkerStatus) GetStarted() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *WorkerStatus) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *WorkerStatus) GetQueueSize() int64 {
	if m != nil {
		return m.QueueSize
	}
	return 0
}

// ResourceSpec describes the amount of resources that pipeline pods should
// request from kubernetes, for scheduling.
type ResourceSpec struct {
	// The number of CPUs each worker needs (partial values are allowed, and
	// encouraged)
	Cpu float32 `protobuf:"fixed32,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// The amount of memory, in bytes, each worker needs (in bytes, with allowed
	// SI suffixes (M, K, G, Mi, Ki, Gi, etc).
	Memory string `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// The number of GPUs each worker needs.
	Gpu int64 `protobuf:"varint,3,opt,name=gpu,proto3" json:"gpu,omitempty"`
}

func (m *ResourceSpec) Reset()                    { *m = ResourceSpec{} }
func (m *ResourceSpec) String() string            { return proto.CompactTextString(m) }
func (*ResourceSpec) ProtoMessage()               {}
func (*ResourceSpec) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{18} }

func (m *ResourceSpec) GetCpu() float32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *ResourceSpec) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *ResourceSpec) GetGpu() int64 {
	if m != nil {
		return m.Gpu
	}
	return 0
}

type JobInfo struct {
	Job             *Job                        `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	Transform       *Transform                  `protobuf:"bytes,2,opt,name=transform" json:"transform,omitempty"`
	Pipeline        *Pipeline                   `protobuf:"bytes,3,opt,name=pipeline" json:"pipeline,omitempty"`
	PipelineVersion uint64                      `protobuf:"varint,13,opt,name=pipeline_version,json=pipelineVersion,proto3" json:"pipeline_version,omitempty"`
	ParallelismSpec *ParallelismSpec            `protobuf:"bytes,12,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress          *Egress                     `protobuf:"bytes,15,opt,name=egress" json:"egress,omitempty"`
	ParentJob       *Job                        `protobuf:"bytes,6,opt,name=parent_job,json=parentJob" json:"parent_job,omitempty"`
	Started         *google_protobuf1.Timestamp `protobuf:"bytes,7,opt,name=started" json:"started,omitempty"`
	Finished        *google_protobuf1.Timestamp `protobuf:"bytes,8,opt,name=finished" json:"finished,omitempty"`
	OutputCommit    *pfs.Commit                 `protobuf:"bytes,9,opt,name=output_commit,json=outputCommit" json:"output_commit,omitempty"`
	State           JobState                    `protobuf:"varint,10,opt,name=state,proto3,enum=pps.JobState" json:"state,omitempty"`
	Reason          string                      `protobuf:"bytes,35,opt,name=reason,proto3" json:"reason,omitempty"`
	Service         *Service                    `protobuf:"bytes,14,opt,name=service" json:"service,omitempty"`
	OutputRepo      *pfs.Repo                   `protobuf:"bytes,18,opt,name=output_repo,json=outputRepo" json:"output_repo,omitempty"`
	OutputBranch    string                      `protobuf:"bytes,17,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	Restart         uint64                      `protobuf:"varint,20,opt,name=restart,proto3" json:"restart,omitempty"`
	DataProcessed   int64                       `protobuf:"varint,22,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped     int64                       `protobuf:"varint,30,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataTotal       int64                       `protobuf:"varint,23,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	Stats           *ProcessStats               `protobuf:"bytes,31,opt,name=stats" json:"stats,omitempty"`
	WorkerStatus    []*WorkerStatus             `protobuf:"bytes,24,rep,name=worker_status,json=workerStatus" json:"worker_status,omitempty"`
	ResourceSpec    *ResourceSpec               `protobuf:"bytes,25,opt,name=resource_spec,json=resourceSpec" json:"resource_spec,omitempty"`
	Input           *Input                      `protobuf:"bytes,26,opt,name=input" json:"input,omitempty"`
	NewBranch       *pfs.BranchInfo             `protobuf:"bytes,27,opt,name=new_branch,json=newBranch" json:"new_branch,omitempty"`
	Incremental     bool                        `protobuf:"varint,28,opt,name=incremental,proto3" json:"incremental,omitempty"`
	StatsCommit     *pfs.Commit                 `protobuf:"bytes,29,opt,name=stats_commit,json=statsCommit" json:"stats_commit,omitempty"`
	EnableStats     bool                        `protobuf:"varint,32,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt            string                      `protobuf:"bytes,33,opt,name=salt,proto3" json:"salt,omitempty"`
	Batch           bool                        `protobuf:"varint,34,opt,name=batch,proto3" json:"batch,omitempty"`
}

func (m *JobInfo) Reset()                    { *m = JobInfo{} }
func (m *JobInfo) String() string            { return proto.CompactTextString(m) }
func (*JobInfo) ProtoMessage()               {}
func (*JobInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{19} }

func (m *JobInfo) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *JobInfo) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *JobInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *JobInfo) GetPipelineVersion() uint64 {
	if m != nil {
		return m.PipelineVersion
	}
	return 0
}

func (m *JobInfo) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *JobInfo) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *JobInfo) GetParentJob() *Job {
	if m != nil {
		return m.ParentJob
	}
	return nil
}

func (m *JobInfo) GetStarted() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *JobInfo) GetFinished() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *JobInfo) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *JobInfo) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STARTING
}

func (m *JobInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *JobInfo) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *JobInfo) GetOutputRepo() *pfs.Repo {
	if m != nil {
		return m.OutputRepo
	}
	return nil
}

func (m *JobInfo) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *JobInfo) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *JobInfo) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *JobInfo) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *JobInfo) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *JobInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *JobInfo) GetWorkerStatus() []*WorkerStatus {
	if m != nil {
		return m.WorkerStatus
	}
	return nil
}

func (m *JobInfo) GetResourceSpec() *ResourceSpec {
	if m != nil {
		return m.ResourceSpec
	}
	return nil
}

func (m *JobInfo) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *JobInfo) GetNewBranch() *pfs.BranchInfo {
	if m != nil {
		return m.NewBranch
	}
	return nil
}

func (m *JobInfo) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *JobInfo) GetStatsCommit() *pfs.Commit {
	if m != nil {
		return m.StatsCommit
	}
	return nil
}

func (m *JobInfo) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *JobInfo) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *JobInfo) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

type Worker struct {
	Name  string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State WorkerState `protobuf:"varint,2,opt,name=state,proto3,enum=pps.WorkerState" json:"state,omitempty"`
}

func (m *Worker) Reset()                    { *m = Worker{} }
func (m *Worker) String() string            { return proto.CompactTextString(m) }
func (*Worker) ProtoMessage()               {}
func (*Worker) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{20} }

func (m *Worker) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Worker) GetState() WorkerState {
	if m != nil {
		return m.State
	}
	return WorkerState_POD_RUNNING
}

type JobInfos struct {
	JobInfo []*JobInfo `protobuf:"bytes,1,rep,name=job_info,json=jobInfo" json:"job_info,omitempty"`
}

func (m *JobInfos) Reset()                    { *m = JobInfos{} }
func (m *JobInfos) String() string            { return proto.CompactTextString(m) }
func (*JobInfos) ProtoMessage()               {}
func (*JobInfos) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{21} }

func (m *JobInfos) GetJobInfo() []*JobInfo {
	if m != nil {
		return m.JobInfo
	}
	return nil
}

type Pipeline struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *Pipeline) Reset()                    { *m = Pipeline{} }
func (m *Pipeline) String() string            { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()               {}
func (*Pipeline) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{22} }

func (m *Pipeline) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PipelineInput struct {
	Name   string      `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	Repo   *pfs.Repo   `protobuf:"bytes,1,opt,name=repo" json:"repo,omitempty"`
	Branch string      `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Glob   string      `protobuf:"bytes,3,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy   bool        `protobuf:"varint,4,opt,name=lazy,proto3" json:"lazy,omitempty"`
	From   *pfs.Commit `protobuf:"bytes,6,opt,name=from" json:"from,omitempty"`
}

func (m *PipelineInput) Reset()                    { *m = PipelineInput{} }
func (m *PipelineInput) String() string            { return proto.CompactTextString(m) }
func (*PipelineInput) ProtoMessage()               {}
func (*PipelineInput) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{23} }

func (m *PipelineInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PipelineInput) GetRepo() *pfs.Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *PipelineInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *PipelineInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *PipelineInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *PipelineInput) GetFrom() *pfs.Commit {
	if m != nil {
		return m.From
	}
	return nil
}

type PipelineInfo struct {
	ID                 string                      `protobuf:"bytes,17,opt,name=id,proto3" json:"id,omitempty"`
	Pipeline           *Pipeline                   `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	Version            uint64                      `protobuf:"varint,11,opt,name=version,proto3" json:"version,omitempty"`
	Transform          *Transform                  `protobuf:"bytes,2,opt,name=transform" json:"transform,omitempty"`
	ParallelismSpec    *ParallelismSpec            `protobuf:"bytes,10,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress             *Egress                     `protobuf:"bytes,15,opt,name=egress" json:"egress,omitempty"`
	CreatedAt          *google_protobuf1.Timestamp `protobuf:"bytes,6,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	State              PipelineState               `protobuf:"varint,7,opt,name=state,proto3,enum=pps.PipelineState" json:"state,omitempty"`
	RecentError        string                      `protobuf:"bytes,8,opt,name=recent_error,json=recentError,proto3" json:"recent_error,omitempty"`
	JobCounts          map[int32]int32             `protobuf:"bytes,9,rep,name=job_counts,json=jobCounts" json:"job_counts,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	OutputBranch       string                      `protobuf:"bytes,16,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ScaleDownThreshold *google_protobuf2.Duration  `protobuf:"bytes,18,opt,name=scale_down_threshold,json=scaleDownThreshold" json:"scale_down_threshold,omitempty"`
	ResourceSpec       *ResourceSpec               `protobuf:"bytes,19,opt,name=resource_spec,json=resourceSpec" json:"resource_spec,omitempty"`
	Input              *Input                      `protobuf:"bytes,20,opt,name=input" json:"input,omitempty"`
	Description        string                      `protobuf:"bytes,21,opt,name=description,proto3" json:"description,omitempty"`
	Incremental        bool                        `protobuf:"varint,22,opt,name=incremental,proto3" json:"incremental,omitempty"`
	CacheSize          string                      `protobuf:"bytes,23,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	EnableStats        bool                        `protobuf:"varint,24,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt               string                      `protobuf:"bytes,25,opt,name=salt,proto3" json:"salt,omitempty"`
	Capability         string                      `protobuf:"bytes,26,opt,name=capability,proto3" json:"capability,omitempty"`
	Batch              bool                        `protobuf:"varint,27,opt,name=batch,proto3" json:"batch,omitempty"`
	Reason             string                      `protobuf:"bytes,28,opt,name=reason,proto3" json:"reason,omitempty"`
	MaxQueueSize       int64                       `protobuf:"varint,29,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	Service            *Service                    `protobuf:"bytes,30,opt,name=service" json:"service,omitempty"`
}

func (m *PipelineInfo) Reset()                    { *m = PipelineInfo{} }
func (m *PipelineInfo) String() string            { return proto.CompactTextString(m) }
func (*PipelineInfo) ProtoMessage()               {}
func (*PipelineInfo) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{24} }

func (m *PipelineInfo) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PipelineInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *PipelineInfo) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PipelineInfo) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *PipelineInfo) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *PipelineInfo) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *PipelineInfo) GetCreatedAt() *google_protobuf1.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PipelineInfo) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PipelineState_PIPELINE_STARTING
}

func (m *PipelineInfo) GetRecentError() string {
	if m != nil {
		return m.RecentError
	}
	return ""
}

func (m *PipelineInfo) GetJobCounts() map[int32]int32 {
	if m != nil {
		return m.JobCounts
	}
	return nil
}

func (m *PipelineInfo) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *PipelineInfo) GetScaleDownThreshold() *google_protobuf2.Duration {
	if m != nil {
		return m.ScaleDownThreshold
	}
	return nil
}

func (m *PipelineInfo) GetResourceSpec() *ResourceSpec {
	if m != nil {
		return m.ResourceSpec
	}
	return nil
}

func (m *PipelineInfo) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *PipelineInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PipelineInfo) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *PipelineInfo) GetCacheSize() string {
	if m != nil {
		return m.CacheSize
	}
	return ""
}

func (m *PipelineInfo) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *PipelineInfo) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *PipelineInfo) GetCapability() string {
	if m != nil {
		return m.Capability
	}
	return ""
}

func (m *PipelineInfo) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *PipelineInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PipelineInfo) GetMaxQueueSize() int64 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *PipelineInfo) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

type PipelineInfos struct {
	PipelineInfo []*PipelineInfo `protobuf:"bytes,1,rep,name=pipeline_info,json=pipelineInfo" json:"pipeline_info,omitempty"`
}

func (m *PipelineInfos) Reset()                    { *m = PipelineInfos{} }
func (m *PipelineInfos) String() string            { return proto.CompactTextString(m) }
func (*PipelineInfos) ProtoMessage()               {}
func (*PipelineInfos) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{25} }

func (m *PipelineInfos) GetPipelineInfo() []*PipelineInfo {
	if m != nil {
		return m.PipelineInfo
	}
	return nil
}

type CreateJobRequest struct {
	Transform       *Transform       `protobuf:"bytes,1,opt,name=transform" json:"transform,omitempty"`
	Pipeline        *Pipeline        `protobuf:"bytes,2,opt,name=pipeline" json:"pipeline,omitempty"`
	PipelineVersion uint64           `protobuf:"varint,10,opt,name=pipeline_version,json=pipelineVersion,proto3" json:"pipeline_version,omitempty"`
	ParallelismSpec *ParallelismSpec `protobuf:"bytes,7,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress          *Egress          `protobuf:"bytes,9,opt,name=egress" json:"egress,omitempty"`
	// When service is defined, we create a long running job
	// by using a k8s RC and Service instead of a k8s Job
	Service      *Service        `protobuf:"bytes,8,opt,name=service" json:"service,omitempty"`
	OutputRepo   *pfs.Repo       `protobuf:"bytes,12,opt,name=output_repo,json=outputRepo" json:"output_repo,omitempty"`
	OutputBranch string          `protobuf:"bytes,11,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ParentJob    *Job            `protobuf:"bytes,13,opt,name=parent_job,json=parentJob" json:"parent_job,omitempty"`
	ResourceSpec *ResourceSpec   `protobuf:"bytes,14,opt,name=resource_spec,json=resourceSpec" json:"resource_spec,omitempty"`
	Input        *Input          `protobuf:"bytes,15,opt,name=input" json:"input,omitempty"`
	NewBranch    *pfs.BranchInfo `protobuf:"bytes,16,opt,name=new_branch,json=newBranch" json:"new_branch,omitempty"`
	Incremental  bool            `protobuf:"varint,17,opt,name=incremental,proto3" json:"incremental,omitempty"`
	EnableStats  bool            `protobuf:"varint,18,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	Salt         string          `protobuf:"bytes,19,opt,name=salt,proto3" json:"salt,omitempty"`
	Batch        bool            `protobuf:"varint,20,opt,name=batch,proto3" json:"batch,omitempty"`
}

func (m *CreateJobRequest) Reset()                    { *m = CreateJobRequest{} }
func (m *CreateJobRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateJobRequest) ProtoMessage()               {}
func (*CreateJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{26} }

func (m *CreateJobRequest) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *CreateJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreateJobRequest) GetPipelineVersion() uint64 {
	if m != nil {
		return m.PipelineVersion
	}
	return 0
}

func (m *CreateJobRequest) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *CreateJobRequest) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *CreateJobRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *CreateJobRequest) GetOutputRepo() *pfs.Repo {
	if m != nil {
		return m.OutputRepo
	}
	return nil
}

func (m *CreateJobRequest) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *CreateJobRequest) GetParentJob() *Job {
	if m != nil {
		return m.ParentJob
	}
	return nil
}

func (m *CreateJobRequest) GetResourceSpec() *ResourceSpec {
	if m != nil {
		return m.ResourceSpec
	}
	return nil
}

func (m *CreateJobRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CreateJobRequest) GetNewBranch() *pfs.BranchInfo {
	if m != nil {
		return m.NewBranch
	}
	return nil
}

func (m *CreateJobRequest) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *CreateJobRequest) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *CreateJobRequest) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *CreateJobRequest) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

type InspectJobRequest struct {
	Job        *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	BlockState bool `protobuf:"varint,2,opt,name=block_state,json=blockState,proto3" json:"block_state,omitempty"`
}

func (m *InspectJobRequest) Reset()                    { *m = InspectJobRequest{} }
func (m *InspectJobRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectJobRequest) ProtoMessage()               {}
func (*InspectJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{27} }

func (m *InspectJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *InspectJobRequest) GetBlockState() bool {
	if m != nil {
		return m.BlockState
	}
	return false
}

type ListJobRequest struct {
	Pipeline     *Pipeline     `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	InputCommit  []*pfs.Commit `protobuf:"bytes,2,rep,name=input_commit,json=inputCommit" json:"input_commit,omitempty"`
	OutputCommit *pfs.Commit   `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit" json:"output_commit,omitempty"`
}

func (m *ListJobRequest) Reset()                    { *m = ListJobRequest{} }
func (m *ListJobRequest) String() string            { return proto.CompactTextString(m) }
func (*ListJobRequest) ProtoMessage()               {}
func (*ListJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{28} }

func (m *ListJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *ListJobRequest) GetInputCommit() []*pfs.Commit {
	if m != nil {
		return m.InputCommit
	}
	return nil
}

func (m *ListJobRequest) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

type DeleteJobRequest struct {
	Job *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
}

func (m *DeleteJobRequest) Reset()                    { *m = DeleteJobRequest{} }
func (m *DeleteJobRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteJobRequest) ProtoMessage()               {}
func (*DeleteJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{29} }

func (m *DeleteJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type StopJobRequest struct {
	Job *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
}

func (m *StopJobRequest) Reset()                    { *m = StopJobRequest{} }
func (m *StopJobRequest) String() string            { return proto.CompactTextString(m) }
func (*StopJobRequest) ProtoMessage()               {}
func (*StopJobRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{30} }

func (m *StopJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type GetLogsRequest struct {
	// The pipeline from which we want to get logs (required if the job in 'job'
	// was created as part of a pipeline. To get logs from a non-orphan job
	// without the pipeline that created it, you need to use ElasticSearch).
	Pipeline *Pipeline `protobuf:"bytes,2,opt,name=pipeline" json:"pipeline,omitempty"`
	// The job from which we want to get logs.
	Job *Job `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	// Names of input files from which we want processing logs. This may contain
	// multiple files, to query pipelines that contain multiple inputs. Each
	// filter may be an absolute path of a file within a pps repo, or it may be
	// a hash for that file (to search for files at specific versions)
	DataFilters []string `protobuf:"bytes,3,rep,name=data_filters,json=dataFilters" json:"data_filters,omitempty"`
	Datum       *Datum   `protobuf:"bytes,6,opt,name=datum" json:"datum,omitempty"`
	// If true get logs from the master process
	Master bool `protobuf:"varint,5,opt,name=master,proto3" json:"master,omitempty"`
	// If true, logs will be streamed.  This is useful for getting logs
	// as the pipeline/job is running.
	Follow bool `protobuf:"varint,7,opt,name=follow,proto3" json:"follow,omitempty"`
}

func (m *GetLogsRequest) Reset()                    { *m = GetLogsRequest{} }
func (m *GetLogsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLogsRequest) ProtoMessage()               {}
func (*GetLogsRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{31} }

func (m *GetLogsRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *GetLogsRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *GetLogsRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

func (m *GetLogsRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *GetLogsRequest) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *GetLogsRequest) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

// LogMessage is a log line from a PPS worker, annotated with metadata
// indicating when and why the line was logged.
type LogMessage struct {
	// The job and pipeline for which a PFS file is being processed (if the job
	// is an orphan job, pipeline name and ID will be unset)
	PipelineName string `protobuf:"bytes,1,opt,name=pipeline_name,json=pipelineName,proto3" json:"pipeline_name,omitempty"`
	JobID        string `protobuf:"bytes,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	WorkerID     string `protobuf:"bytes,7,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	DatumID      string `protobuf:"bytes,9,opt,name=datum_id,json=datumId,proto3" json:"datum_id,omitempty"`
	Master       bool   `protobuf:"varint,10,opt,name=master,proto3" json:"master,omitempty"`
	// The PFS files being processed (one per pipeline/job input)
	Data []*InputFile `protobuf:"bytes,4,rep,name=data" json:"data,omitempty"`
	// User is true if log message comes from the users code.
	User bool `protobuf:"varint,8,opt,name=user,proto3" json:"user,omitempty"`
	// The message logged, and the time at which it was logged
	Ts      *google_protobuf1.Timestamp `protobuf:"bytes,5,opt,name=ts" json:"ts,omitempty"`
	Message string                      `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *LogMessage) Reset()                    { *m = LogMessage{} }
func (m *LogMessage) String() string            { return proto.CompactTextString(m) }
func (*LogMessage) ProtoMessage()               {}
func (*LogMessage) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{32} }

func (m *LogMessage) GetPipelineName() string {
	if m != nil {
		return m.PipelineName
	}
	return ""
}

func (m *LogMessage) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *LogMessage) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *LogMessage) GetDatumID() string {
	if m != nil {
		return m.DatumID
	}
	return ""
}

func (m *LogMessage) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *LogMessage) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LogMessage) GetUser() bool {
	if m != nil {
		return m.User
	}
	return false
}

func (m *LogMessage) GetTs() *google_protobuf1.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *LogMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RestartDatumRequest struct {
	Job         *Job     `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	DataFilters []string `protobuf:"bytes,2,rep,name=data_filters,json=dataFilters" json:"data_filters,omitempty"`
}

func (m *RestartDatumRequest) Reset()                    { *m = RestartDatumRequest{} }
func (m *RestartDatumRequest) String() string            { return proto.CompactTextString(m) }
func (*RestartDatumRequest) ProtoMessage()               {}
func (*RestartDatumRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{33} }

func (m *RestartDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *RestartDatumRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

type InspectDatumRequest struct {
	Datum *Datum `protobuf:"bytes,1,opt,name=datum" json:"datum,omitempty"`
}

func (m *InspectDatumRequest) Reset()                    { *m = InspectDatumRequest{} }
func (m *InspectDatumRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectDatumRequest) ProtoMessage()               {}
func (*InspectDatumRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{34} }

func (m *InspectDatumRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

type ListDatumRequest struct {
	Job      *Job  `protobuf:"bytes,1,opt,name=job" json:"job,omitempty"`
	PageSize int64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	Page     int64 `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *ListDatumRequest) Reset()                    { *m = ListDatumRequest{} }
func (m *ListDatumRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDatumRequest) ProtoMessage()               {}
func (*ListDatumRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{35} }

func (m *ListDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *ListDatumRequest) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListDatumRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type ListDatumResponse struct {
	DatumInfos []*DatumInfo `protobuf:"bytes,1,rep,name=datum_infos,json=datumInfos" json:"datum_infos,omitempty"`
	TotalPages int64        `protobuf:"varint,2,opt,name=total_pages,json=totalPages,proto3" json:"total_pages,omitempty"`
	Page       int64        `protobuf:"varint,3,opt,name=page,proto3" json:"page,omitempty"`
}

func (m *ListDatumResponse) Reset()                    { *m = ListDatumResponse{} }
func (m *ListDatumResponse) String() string            { return proto.CompactTextString(m) }
func (*ListDatumResponse) ProtoMessage()               {}
func (*ListDatumResponse) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{36} }

func (m *ListDatumResponse) GetDatumInfos() []*DatumInfo {
	if m != nil {
		return m.DatumInfos
	}
	return nil
}

func (m *ListDatumResponse) GetTotalPages() int64 {
	if m != nil {
		return m.TotalPages
	}
	return 0
}

func (m *ListDatumResponse) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

type CreatePipelineRequest struct {
	Pipeline           *Pipeline                  `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	Transform          *Transform                 `protobuf:"bytes,2,opt,name=transform" json:"transform,omitempty"`
	ParallelismSpec    *ParallelismSpec           `protobuf:"bytes,7,opt,name=parallelism_spec,json=parallelismSpec" json:"parallelism_spec,omitempty"`
	Egress             *Egress                    `protobuf:"bytes,9,opt,name=egress" json:"egress,omitempty"`
	Update             bool                       `protobuf:"varint,5,opt,name=update,proto3" json:"update,omitempty"`
	OutputBranch       string                     `protobuf:"bytes,10,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ScaleDownThreshold *google_protobuf2.Duration `protobuf:"bytes,11,opt,name=scale_down_threshold,json=scaleDownThreshold" json:"scale_down_threshold,omitempty"`
	ResourceSpec       *ResourceSpec              `protobuf:"bytes,12,opt,name=resource_spec,json=resourceSpec" json:"resource_spec,omitempty"`
	Input              *Input                     `protobuf:"bytes,13,opt,name=input" json:"input,omitempty"`
	Description        string                     `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	Incremental        bool                       `protobuf:"varint,15,opt,name=incremental,proto3" json:"incremental,omitempty"`
	CacheSize          string                     `protobuf:"bytes,16,opt,name=cache_size,json=cacheSize,proto3" json:"cache_size,omitempty"`
	EnableStats        bool                       `protobuf:"varint,17,opt,name=enable_stats,json=enableStats,proto3" json:"enable_stats,omitempty"`
	// Reprocess forces the pipeline to reprocess all datums.
	// It only has meaning if Update is true
	Reprocess    bool     `protobuf:"varint,18,opt,name=reprocess,proto3" json:"reprocess,omitempty"`
	Batch        bool     `protobuf:"varint,19,opt,name=batch,proto3" json:"batch,omitempty"`
	MaxQueueSize int64    `protobuf:"varint,20,opt,name=max_queue_size,json=maxQueueSize,proto3" json:"max_queue_size,omitempty"`
	Service      *Service `protobuf:"bytes,21,opt,name=service" json:"service,omitempty"`
}

func (m *CreatePipelineRequest) Reset()                    { *m = CreatePipelineRequest{} }
func (m *CreatePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*CreatePipelineRequest) ProtoMessage()               {}
func (*CreatePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{37} }

func (m *CreatePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreatePipelineRequest) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *CreatePipelineRequest) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *CreatePipelineRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

func (m *CreatePipelineRequest) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *CreatePipelineRequest) GetScaleDownThreshold() *google_protobuf2.Duration {
	if m != nil {
		return m.ScaleDownThreshold
	}
	return nil
}

func (m *CreatePipelineRequest) GetResourceSpec() *ResourceSpec {
	if m != nil {
		return m.ResourceSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CreatePipelineRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreatePipelineRequest) GetIncremental() bool {
	if m != nil {
		return m.Incremental
	}
	return false
}

func (m *CreatePipelineRequest) GetCacheSize() string {
	if m != nil {
		return m.CacheSize
	}
	return ""
}

func (m *CreatePipelineRequest) GetEnableStats() bool {
	if m != nil {
		return m.EnableStats
	}
	return false
}

func (m *CreatePipelineRequest) GetReprocess() bool {
	if m != nil {
		return m.Reprocess
	}
	return false
}

func (m *CreatePipelineRequest) GetBatch() bool {
	if m != nil {
		return m.Batch
	}
	return false
}

func (m *CreatePipelineRequest) GetMaxQueueSize() int64 {
	if m != nil {
		return m.MaxQueueSize
	}
	return 0
}

func (m *CreatePipelineRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

type InspectPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *InspectPipelineRequest) Reset()                    { *m = InspectPipelineRequest{} }
func (m *InspectPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*InspectPipelineRequest) ProtoMessage()               {}
func (*InspectPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{38} }

func (m *InspectPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type ListPipelineRequest struct {
}

func (m *ListPipelineRequest) Reset()                    { *m = ListPipelineRequest{} }
func (m *ListPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPipelineRequest) ProtoMessage()               {}
func (*ListPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{39} }

type DeletePipelineRequest struct {
	Pipeline   *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	DeleteJobs bool      `protobuf:"varint,2,opt,name=delete_jobs,json=deleteJobs,proto3" json:"delete_jobs,omitempty"`
	DeleteRepo bool      `protobuf:"varint,3,opt,name=delete_repo,json=deleteRepo,proto3" json:"delete_repo,omitempty"`
	All        bool      `protobuf:"varint,4,opt,name=all,proto3" json:"all,omitempty"`
}

func (m *DeletePipelineRequest) Reset()                    { *m = DeletePipelineRequest{} }
func (m *DeletePipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*DeletePipelineRequest) ProtoMessage()               {}
func (*DeletePipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{40} }

func (m *DeletePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *DeletePipelineRequest) GetDeleteJobs() bool {
	if m != nil {
		return m.DeleteJobs
	}
	return false
}

func (m *DeletePipelineRequest) GetDeleteRepo() bool {
	if m != nil {
		return m.DeleteRepo
	}
	return false
}

func (m *DeletePipelineRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type StartPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *StartPipelineRequest) Reset()                    { *m = StartPipelineRequest{} }
func (m *StartPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*StartPipelineRequest) ProtoMessage()               {}
func (*StartPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{41} }

func (m *StartPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type StopPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
}

func (m *StopPipelineRequest) Reset()                    { *m = StopPipelineRequest{} }
func (m *StopPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*StopPipelineRequest) ProtoMessage()               {}
func (*StopPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{42} }

func (m *StopPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type RerunPipelineRequest struct {
	Pipeline *Pipeline     `protobuf:"bytes,1,opt,name=pipeline" json:"pipeline,omitempty"`
	Exclude  []*pfs.Commit `protobuf:"bytes,2,rep,name=exclude" json:"exclude,omitempty"`
	Include  []*pfs.Commit `protobuf:"bytes,3,rep,name=include" json:"include,omitempty"`
}

func (m *RerunPipelineRequest) Reset()                    { *m = RerunPipelineRequest{} }
func (m *RerunPipelineRequest) String() string            { return proto.CompactTextString(m) }
func (*RerunPipelineRequest) ProtoMessage()               {}
func (*RerunPipelineRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{43} }

func (m *RerunPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *RerunPipelineRequest) GetExclude() []*pfs.Commit {
	if m != nil {
		return m.Exclude
	}
	return nil
}

func (m *RerunPipelineRequest) GetInclude() []*pfs.Commit {
	if m != nil {
		return m.Include
	}
	return nil
}

type GarbageCollectRequest struct {
}

func (m *GarbageCollectRequest) Reset()                    { *m = GarbageCollectRequest{} }
func (m *GarbageCollectRequest) String() string            { return proto.CompactTextString(m) }
func (*GarbageCollectRequest) ProtoMessage()               {}
func (*GarbageCollectRequest) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{44} }

type GarbageCollectResponse struct {
}

func (m *GarbageCollectResponse) Reset()                    { *m = GarbageCollectResponse{} }
func (m *GarbageCollectResponse) String() string            { return proto.CompactTextString(m) }
func (*GarbageCollectResponse) ProtoMessage()               {}
func (*GarbageCollectResponse) Descriptor() ([]byte, []int) { return fileDescriptorPps, []int{45} }

func init() {
	proto.RegisterType((*Secret)(nil), "pps.Secret")
	proto.RegisterType((*Transform)(nil), "pps.Transform")
	proto.RegisterType((*Egress)(nil), "pps.Egress")
	proto.RegisterType((*Job)(nil), "pps.Job")
	proto.RegisterType((*Service)(nil), "pps.Service")
	proto.RegisterType((*AtomInput)(nil), "pps.AtomInput")
	proto.RegisterType((*CronInput)(nil), "pps.CronInput")
	proto.RegisterType((*Input)(nil), "pps.Input")
	proto.RegisterType((*JobInput)(nil), "pps.JobInput")
	proto.RegisterType((*ParallelismSpec)(nil), "pps.ParallelismSpec")
	proto.RegisterType((*InputFile)(nil), "pps.InputFile")
	proto.RegisterType((*Datum)(nil), "pps.Datum")
	proto.RegisterType((*DatumInfo)(nil), "pps.DatumInfo")
	proto.RegisterType((*DatumInfos)(nil), "pps.DatumInfos")
	proto.RegisterType((*Aggregate)(nil), "pps.Aggregate")
	proto.RegisterType((*ProcessStats)(nil), "pps.ProcessStats")
	proto.RegisterType((*AggregateProcessStats)(nil), "pps.AggregateProcessStats")
	proto.RegisterType((*WorkerStatus)(nil), "pps.WorkerStatus")
	proto.RegisterType((*ResourceSpec)(nil), "pps.ResourceSpec")
	proto.RegisterType((*JobInfo)(nil), "pps.JobInfo")
	proto.RegisterType((*Worker)(nil), "pps.Worker")
	proto.RegisterType((*JobInfos)(nil), "pps.JobInfos")
	proto.RegisterType((*Pipeline)(nil), "pps.Pipeline")
	proto.RegisterType((*PipelineInput)(nil), "pps.PipelineInput")
	proto.RegisterType((*PipelineInfo)(nil), "pps.PipelineInfo")
	proto.RegisterType((*PipelineInfos)(nil), "pps.PipelineInfos")
	proto.RegisterType((*CreateJobRequest)(nil), "pps.CreateJobRequest")
	proto.RegisterType((*InspectJobRequest)(nil), "pps.InspectJobRequest")
	proto.RegisterType((*ListJobRequest)(nil), "pps.ListJobRequest")
	proto.RegisterType((*DeleteJobRequest)(nil), "pps.DeleteJobRequest")
	proto.RegisterType((*StopJobRequest)(nil), "pps.StopJobRequest")
	proto.RegisterType((*GetLogsRequest)(nil), "pps.GetLogsRequest")
	proto.RegisterType((*LogMessage)(nil), "pps.LogMessage")
	proto.RegisterType((*RestartDatumRequest)(nil), "pps.RestartDatumRequest")
	proto.RegisterType((*InspectDatumRequest)(nil), "pps.InspectDatumRequest")
	proto.RegisterType((*ListDatumRequest)(nil), "pps.ListDatumRequest")
	proto.RegisterType((*ListDatumResponse)(nil), "pps.ListDatumResponse")
	proto.RegisterType((*CreatePipelineRequest)(nil), "pps.CreatePipelineRequest")
	proto.RegisterType((*InspectPipelineRequest)(nil), "pps.InspectPipelineRequest")
	proto.RegisterType((*ListPipelineRequest)(nil), "pps.ListPipelineRequest")
	proto.RegisterType((*DeletePipelineRequest)(nil), "pps.DeletePipelineRequest")
	proto.RegisterType((*StartPipelineRequest)(nil), "pps.StartPipelineRequest")
	proto.RegisterType((*StopPipelineRequest)(nil), "pps.StopPipelineRequest")
	proto.RegisterType((*RerunPipelineRequest)(nil), "pps.RerunPipelineRequest")
	proto.RegisterType((*GarbageCollectRequest)(nil), "pps.GarbageCollectRequest")
	proto.RegisterType((*GarbageCollectResponse)(nil), "pps.GarbageCollectResponse")
	proto.RegisterEnum("pps.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("pps.DatumState", DatumState_name, DatumState_value)
	proto.RegisterEnum("pps.WorkerState", WorkerState_name, WorkerState_value)
	proto.RegisterEnum("pps.PipelineState", PipelineState_name, PipelineState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error)
	InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error)
	ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (*JobInfos, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error)
	ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (*ListDatumResponse, error)
	RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error)
	ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (*PipelineInfos, error)
	DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	RerunPipeline(ctx context.Context, in *RerunPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error)
	// Garbage collection
	GarbageCollect(ctx context.Context, in *GarbageCollectRequest, opts ...grpc.CallOption) (*GarbageCollectResponse, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := grpc.Invoke(ctx, "/pps.API/CreateJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error) {
	out := new(JobInfo)
	err := grpc.Invoke(ctx, "/pps.API/InspectJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (*JobInfos, error) {
	out := new(JobInfos)
	err := grpc.Invoke(ctx, "/pps.API/ListJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/DeleteJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/StopJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error) {
	out := new(DatumInfo)
	err := grpc.Invoke(ctx, "/pps.API/InspectDatum", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (*ListDatumResponse, error) {
	out := new(ListDatumResponse)
	err := grpc.Invoke(ctx, "/pps.API/ListDatum", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/RestartDatum", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/CreatePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error) {
	out := new(PipelineInfo)
	err := grpc.Invoke(ctx, "/pps.API/InspectPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (*PipelineInfos, error) {
	out := new(PipelineInfos)
	err := grpc.Invoke(ctx, "/pps.API/ListPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/DeletePipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/StartPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/StopPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RerunPipeline(ctx context.Context, in *RerunPipelineRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/RerunPipeline", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *google_protobuf.Empty, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/pps.API/DeleteAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[0], c.cc, "/pps.API/GetLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetLogsClient interface {
	Recv() (*LogMessage, error)
	grpc.ClientStream
}

type aPIGetLogsClient struct {
	grpc.ClientStream
}

func (x *aPIGetLogsClient) Recv() (*LogMessage, error) {
	m := new(LogMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GarbageCollect(ctx context.Context, in *GarbageCollectRequest, opts ...grpc.CallOption) (*GarbageCollectResponse, error) {
	out := new(GarbageCollectResponse)
	err := grpc.Invoke(ctx, "/pps.API/GarbageCollect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	CreateJob(context.Context, *CreateJobRequest) (*Job, error)
	InspectJob(context.Context, *InspectJobRequest) (*JobInfo, error)
	ListJob(context.Context, *ListJobRequest) (*JobInfos, error)
	DeleteJob(context.Context, *DeleteJobRequest) (*google_protobuf.Empty, error)
	StopJob(context.Context, *StopJobRequest) (*google_protobuf.Empty, error)
	InspectDatum(context.Context, *InspectDatumRequest) (*DatumInfo, error)
	ListDatum(context.Context, *ListDatumRequest) (*ListDatumResponse, error)
	RestartDatum(context.Context, *RestartDatumRequest) (*google_protobuf.Empty, error)
	CreatePipeline(context.Context, *CreatePipelineRequest) (*google_protobuf.Empty, error)
	InspectPipeline(context.Context, *InspectPipelineRequest) (*PipelineInfo, error)
	ListPipeline(context.Context, *ListPipelineRequest) (*PipelineInfos, error)
	DeletePipeline(context.Context, *DeletePipelineRequest) (*google_protobuf.Empty, error)
	StartPipeline(context.Context, *StartPipelineRequest) (*google_protobuf.Empty, error)
	StopPipeline(context.Context, *StopPipelineRequest) (*google_protobuf.Empty, error)
	RerunPipeline(context.Context, *RerunPipelineRequest) (*google_protobuf.Empty, error)
	// DeleteAll deletes everything
	DeleteAll(context.Context, *google_protobuf.Empty) (*google_protobuf.Empty, error)
	GetLogs(*GetLogsRequest, API_GetLogsServer) error
	// Garbage collection
	GarbageCollect(context.Context, *GarbageCollectRequest) (*GarbageCollectResponse, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/CreateJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateJob(ctx, req.(*CreateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectJob(ctx, req.(*InspectJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListJob(ctx, req.(*ListJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StopJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopJob(ctx, req.(*StopJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectDatum(ctx, req.(*InspectDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListDatum(ctx, req.(*ListDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RestartDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RestartDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/RestartDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RestartDatum(ctx, req.(*RestartDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/CreatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreatePipeline(ctx, req.(*CreatePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/InspectPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectPipeline(ctx, req.(*InspectPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/ListPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListPipeline(ctx, req.(*ListPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeletePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeletePipeline(ctx, req.(*DeletePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StartPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartPipeline(ctx, req.(*StartPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/StopPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopPipeline(ctx, req.(*StopPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RerunPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RerunPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RerunPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/RerunPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RerunPipeline(ctx, req.(*RerunPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*google_protobuf.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetLogs(m, &aPIGetLogsServer{stream})
}

type API_GetLogsServer interface {
	Send(*LogMessage) error
	grpc.ServerStream
}

type aPIGetLogsServer struct {
	grpc.ServerStream
}

func (x *aPIGetLogsServer) Send(m *LogMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GarbageCollect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GarbageCollectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GarbageCollect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps.API/GarbageCollect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GarbageCollect(ctx, req.(*GarbageCollectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pps.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJob",
			Handler:    _API_CreateJob_Handler,
		},
		{
			MethodName: "InspectJob",
			Handler:    _API_InspectJob_Handler,
		},
		{
			MethodName: "ListJob",
			Handler:    _API_ListJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _API_DeleteJob_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _API_StopJob_Handler,
		},
		{
			MethodName: "InspectDatum",
			Handler:    _API_InspectDatum_Handler,
		},
		{
			MethodName: "ListDatum",
			Handler:    _API_ListDatum_Handler,
		},
		{
			MethodName: "RestartDatum",
			Handler:    _API_RestartDatum_Handler,
		},
		{
			MethodName: "CreatePipeline",
			Handler:    _API_CreatePipeline_Handler,
		},
		{
			MethodName: "InspectPipeline",
			Handler:    _API_InspectPipeline_Handler,
		},
		{
			MethodName: "ListPipeline",
			Handler:    _API_ListPipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _API_DeletePipeline_Handler,
		},
		{
			MethodName: "StartPipeline",
			Handler:    _API_StartPipeline_Handler,
		},
		{
			MethodName: "StopPipeline",
			Handler:    _API_StopPipeline_Handler,
		},
		{
			MethodName: "RerunPipeline",
			Handler:    _API_RerunPipeline_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
		{
			MethodName: "GarbageCollect",
			Handler:    _API_GarbageCollect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetLogs",
			Handler:       _API_GetLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client/pps/pps.proto",
}

func (m *Secret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.MountPath) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.MountPath)))
		i += copy(dAtA[i:], m.MountPath)
	}
	if len(m.EnvVar) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.EnvVar)))
		i += copy(dAtA[i:], m.EnvVar)
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	return i, nil
}

func (m *Transform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transform) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Image) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Env) > 0 {
		for k, _ := range m.Env {
			dAtA[i] = 0x1a
			i++
			v := m.Env[k]
			mapSize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Secrets) > 0 {
		for _, msg := range m.Secrets {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		dAtA2 := make([]byte, len(m.AcceptReturnCode)*10)
		var j1 int
		for _, num1 := range m.AcceptReturnCode {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.Debug {
		dAtA[i] = 0x38
		i++
		if m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Egress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.URL)))
		i += copy(dAtA[i:], m.URL)
	}
	return i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	return i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InternalPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ExternalPort))
	}
	return i, nil
}

func (m *AtomInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AtomInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x30
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FromCommit) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.FromCommit)))
		i += copy(dAtA[i:], m.FromCommit)
	}
	return i, nil
}

func (m *CronInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Repo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i += copy(dAtA[i:], m.Repo)
	}
	if len(m.Commit) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i += copy(dAtA[i:], m.Commit)
	}
	if len(m.Spec) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Spec)))
		i += copy(dAtA[i:], m.Spec)
	}
	if m.Start != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Start.Size()))
		n3, err := m.Start.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Input) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Atom != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Atom.Size()))
		n4, err := m.Atom.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Cross) > 0 {
		for _, msg := range m.Cross {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Union) > 0 {
		for _, msg := range m.Union {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Cron != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Cron.Size()))
		n5, err := m.Cron.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *JobInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Commit != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Commit.Size()))
		n6, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x18
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *ParallelismSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelismSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constant != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Constant))
	}
	if m.Coefficient != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Pps(dAtA, i, uint64(math.Float64bits(float64(m.Coefficient))))
	}
	return i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if len(m.Hash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Hash)))
		i += copy(dAtA[i:], m.Hash)
	}
	return i, nil
}

func (m *Datum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Datum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Job != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n7, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *DatumInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n8, err := m.Datum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n9, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.PfsState != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PfsState.Size()))
		n10, err := m.PfsState.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DatumInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatumInfo) > 0 {
		for _, msg := range m.DatumInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Count))
	}
	if m.Mean != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Pps(dAtA, i, uint64(math.Float64bits(float64(m.Mean))))
	}
	if m.Stddev != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Pps(dAtA, i, uint64(math.Float64bits(float64(m.Stddev))))
	}
	if m.FifthPercentile != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Pps(dAtA, i, uint64(math.Float64bits(float64(m.FifthPercentile))))
	}
	if m.NinetyFifthPercentile != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Pps(dAtA, i, uint64(math.Float64bits(float64(m.NinetyFifthPercentile))))
	}
	return i, nil
}

func (m *ProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadTime.Size()))
		n11, err := m.DownloadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.ProcessTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ProcessTime.Size()))
		n12, err := m.ProcessTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.UploadTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadTime.Size()))
		n13, err := m.UploadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.DownloadBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes))
	}
	return i, nil
}

func (m *AggregateProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DownloadTime != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadTime.Size()))
		n14, err := m.DownloadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.ProcessTime != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ProcessTime.Size()))
		n15, err := m.ProcessTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.UploadTime != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadTime.Size()))
		n16, err := m.UploadTime.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DownloadBytes != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes.Size()))
		n17, err := m.DownloadBytes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.UploadBytes != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes.Size()))
		n18, err := m.UploadBytes.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *WorkerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.WorkerID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i += copy(dAtA[i:], m.WorkerID)
	}
	if len(m.JobID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i += copy(dAtA[i:], m.JobID)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Started != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n19, err := m.Started.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Stats != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n20, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.QueueSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.QueueSize))
	}
	return i, nil
}

func (m *ResourceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cpu != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Pps(dAtA, i, uint32(math.Float32bits(float32(m.Cpu))))
	}
	if len(m.Memory) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Memory)))
		i += copy(dAtA[i:], m.Memory)
	}
	if m.Gpu != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Gpu))
	}
	return i, nil
}

func (m *JobInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n21, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n22, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n23, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.ParentJob != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParentJob.Size()))
		n24, err := m.ParentJob.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Started != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Started.Size()))
		n25, err := m.Started.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Finished != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Finished.Size()))
		n26, err := m.Finished.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n27, err := m.OutputCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.State != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n28, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.PipelineVersion != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PipelineVersion))
	}
	if m.Service != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n29, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Egress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n30, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.OutputRepo != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputRepo.Size()))
		n31, err := m.OutputRepo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Restart != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
	}
	if m.DataTotal != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
	}
	if len(m.WorkerStatus) > 0 {
		for _, msg := range m.WorkerStatus {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ResourceSpec != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceSpec.Size()))
		n32, err := m.ResourceSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Input != nil {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n33, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.NewBranch != nil {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.NewBranch.Size()))
		n34, err := m.NewBranch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Incremental {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StatsCommit != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.StatsCommit.Size()))
		n35, err := m.StatsCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.DataSkipped != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
	}
	if m.Stats != nil {
		dAtA[i] = 0xfa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Stats.Size()))
		n36, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.EnableStats {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Batch {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *Worker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Worker) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *JobInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JobInfo) > 0 {
		for _, msg := range m.JobInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *PipelineInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Repo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Repo.Size()))
		n37, err := m.Repo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.Branch) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i += copy(dAtA[i:], m.Branch)
	}
	if len(m.Glob) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i += copy(dAtA[i:], m.Glob)
	}
	if m.Lazy {
		dAtA[i] = 0x20
		i++
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.From != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.From.Size()))
		n38, err := m.From.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *PipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n39, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n40, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.CreatedAt != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.CreatedAt.Size()))
		n41, err := m.CreatedAt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.State != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.State))
	}
	if len(m.RecentError) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.RecentError)))
		i += copy(dAtA[i:], m.RecentError)
	}
	if len(m.JobCounts) > 0 {
		for k, _ := range m.JobCounts {
			dAtA[i] = 0x4a
			i++
			v := m.JobCounts[k]
			mapSize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			i = encodeVarintPps(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPps(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintPps(dAtA, i, uint64(v))
		}
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n42, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Version != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Version))
	}
	if m.Egress != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n43, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if len(m.ID) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.ScaleDownThreshold != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ScaleDownThreshold.Size()))
		n44, err := m.ScaleDownThreshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.ResourceSpec != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceSpec.Size()))
		n45, err := m.ResourceSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Input != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n46, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Incremental {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CacheSize) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.CacheSize)))
		i += copy(dAtA[i:], m.CacheSize)
	}
	if m.EnableStats {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if len(m.Capability) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Capability)))
		i += copy(dAtA[i:], m.Capability)
	}
	if m.Batch {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if m.MaxQueueSize != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		dAtA[i] = 0xf2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n47, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *PipelineInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, msg := range m.PipelineInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreateJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Transform != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n48, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n49, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n50, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Service != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n51, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Egress != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n52, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.PipelineVersion != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PipelineVersion))
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.OutputRepo != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputRepo.Size()))
		n53, err := m.OutputRepo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.ParentJob != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParentJob.Size()))
		n54, err := m.ParentJob.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.ResourceSpec != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceSpec.Size()))
		n55, err := m.ResourceSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.Input != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n56, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.NewBranch != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.NewBranch.Size()))
		n57, err := m.NewBranch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.Incremental {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EnableStats {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.Batch {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InspectJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n58, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.BlockState {
		dAtA[i] = 0x10
		i++
		if m.BlockState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ListJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n59, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.InputCommit) > 0 {
		for _, msg := range m.InputCommit {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.OutputCommit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.OutputCommit.Size()))
		n60, err := m.OutputCommit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	return i, nil
}

func (m *DeleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n61, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	return i, nil
}

func (m *StopJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopJobRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n62, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *GetLogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLogsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n63, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Pipeline != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n64, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Master {
		dAtA[i] = 0x28
		i++
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Datum != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n65, err := m.Datum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Follow {
		dAtA[i] = 0x38
		i++
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LogMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PipelineName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.PipelineName)))
		i += copy(dAtA[i:], m.PipelineName)
	}
	if len(m.JobID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i += copy(dAtA[i:], m.JobID)
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ts != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Ts.Size()))
		n66, err := m.Ts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.WorkerID) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i += copy(dAtA[i:], m.WorkerID)
	}
	if m.User {
		dAtA[i] = 0x40
		i++
		if m.User {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DatumID) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.DatumID)))
		i += copy(dAtA[i:], m.DatumID)
	}
	if m.Master {
		dAtA[i] = 0x50
		i++
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RestartDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n67, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *InspectDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Datum != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Datum.Size()))
		n68, err := m.Datum.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *ListDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Job != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Job.Size()))
		n69, err := m.Job.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.PageSize))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *ListDatumResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DatumInfos) > 0 {
		for _, msg := range m.DatumInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalPages != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.TotalPages))
	}
	if m.Page != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Page))
	}
	return i, nil
}

func (m *CreatePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n70, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.Transform != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Transform.Size()))
		n71, err := m.Transform.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.Update {
		dAtA[i] = 0x28
		i++
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ParallelismSpec != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ParallelismSpec.Size()))
		n72, err := m.ParallelismSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Egress != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Egress.Size()))
		n73, err := m.Egress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.OutputBranch) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i += copy(dAtA[i:], m.OutputBranch)
	}
	if m.ScaleDownThreshold != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ScaleDownThreshold.Size()))
		n74, err := m.ScaleDownThreshold.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.ResourceSpec != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.ResourceSpec.Size()))
		n75, err := m.ResourceSpec.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.Input != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Input.Size()))
		n76, err := m.Input.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if m.Incremental {
		dAtA[i] = 0x78
		i++
		if m.Incremental {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CacheSize) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(len(m.CacheSize)))
		i += copy(dAtA[i:], m.CacheSize)
	}
	if m.EnableStats {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.EnableStats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Reprocess {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.Reprocess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Batch {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		if m.Batch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxQueueSize != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Service.Size()))
		n77, err := m.Service.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}

func (m *InspectPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n78, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *ListPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeletePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n79, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.DeleteJobs {
		dAtA[i] = 0x10
		i++
		if m.DeleteJobs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DeleteRepo {
		dAtA[i] = 0x18
		i++
		if m.DeleteRepo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.All {
		dAtA[i] = 0x20
		i++
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *StartPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n80, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *StopPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n81, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	return i, nil
}

func (m *RerunPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RerunPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pipeline != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPps(dAtA, i, uint64(m.Pipeline.Size()))
		n82, err := m.Pipeline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if len(m.Exclude) > 0 {
		for _, msg := range m.Exclude {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Include) > 0 {
		for _, msg := range m.Include {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPps(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GarbageCollectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GarbageCollectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GarbageCollectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GarbageCollectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeFixed64Pps(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Pps(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPps(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Secret) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.EnvVar)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Transform) Size() (n int) {
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		l = 0
		for _, e := range m.AcceptReturnCode {
			l += sovPps(uint64(e))
		}
		n += 1 + sovPps(uint64(l)) + l
	}
	if m.Debug {
		n += 2
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *Egress) Size() (n int) {
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Job) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Service) Size() (n int) {
	var l int
	_ = l
	if m.InternalPort != 0 {
		n += 1 + sovPps(uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		n += 1 + sovPps(uint64(m.ExternalPort))
	}
	return n
}

func (m *AtomInput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.FromCommit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *CronInput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Input) Size() (n int) {
	var l int
	_ = l
	if m.Atom != nil {
		l = m.Atom.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cross) > 0 {
		for _, e := range m.Cross {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Union) > 0 {
		for _, e := range m.Union {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Cron != nil {
		l = m.Cron.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *JobInput) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *ParallelismSpec) Size() (n int) {
	var l int
	_ = l
	if m.Constant != 0 {
		n += 1 + sovPps(uint64(m.Constant))
	}
	if m.Coefficient != 0 {
		n += 9
	}
	return n
}

func (m *InputFile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Datum) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *DatumInfo) Size() (n int) {
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PfsState != nil {
		l = m.PfsState.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *DatumInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.DatumInfo) > 0 {
		for _, e := range m.DatumInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *Aggregate) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPps(uint64(m.Count))
	}
	if m.Mean != 0 {
		n += 9
	}
	if m.Stddev != 0 {
		n += 9
	}
	if m.FifthPercentile != 0 {
		n += 9
	}
	if m.NinetyFifthPercentile != 0 {
		n += 9
	}
	return n
}

func (m *ProcessStats) Size() (n int) {
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != 0 {
		n += 1 + sovPps(uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		n += 1 + sovPps(uint64(m.UploadBytes))
	}
	return n
}

func (m *AggregateProcessStats) Size() (n int) {
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != nil {
		l = m.DownloadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadBytes != nil {
		l = m.UploadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *WorkerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.QueueSize != 0 {
		n += 1 + sovPps(uint64(m.QueueSize))
	}
	return n
}

func (m *ResourceSpec) Size() (n int) {
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 5
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Gpu != 0 {
		n += 1 + sovPps(uint64(m.Gpu))
	}
	return n
}

func (m *JobInfo) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParentJob != nil {
		l = m.ParentJob.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PipelineVersion != 0 {
		n += 1 + sovPps(uint64(m.PipelineVersion))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.OutputRepo != nil {
		l = m.OutputRepo.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 2 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 2 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataTotal != 0 {
		n += 2 + sovPps(uint64(m.DataTotal))
	}
	if len(m.WorkerStatus) > 0 {
		for _, e := range m.WorkerStatus {
			l = e.Size()
			n += 2 + l + sovPps(uint64(l))
		}
	}
	if m.ResourceSpec != nil {
		l = m.ResourceSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.NewBranch != nil {
		l = m.NewBranch.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 3
	}
	if m.StatsCommit != nil {
		l = m.StatsCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DataSkipped != 0 {
		n += 2 + sovPps(uint64(m.DataSkipped))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	return n
}

func (m *Worker) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	return n
}

func (m *JobInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.JobInfo) > 0 {
		for _, e := range m.JobInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *Pipeline) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *PipelineInput) Size() (n int) {
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *PipelineInfo) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.RecentError)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.JobCounts) > 0 {
		for k, v := range m.JobCounts {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPps(uint64(k)) + 1 + sovPps(uint64(v))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPps(uint64(m.Version))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ScaleDownThreshold != nil {
		l = m.ScaleDownThreshold.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.ResourceSpec != nil {
		l = m.ResourceSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 3
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Capability)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.MaxQueueSize != 0 {
		n += 2 + sovPps(uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	return n
}

func (m *PipelineInfos) Size() (n int) {
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, e := range m.PipelineInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *CreateJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PipelineVersion != 0 {
		n += 1 + sovPps(uint64(m.PipelineVersion))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OutputRepo != nil {
		l = m.OutputRepo.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParentJob != nil {
		l = m.ParentJob.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceSpec != nil {
		l = m.ResourceSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.NewBranch != nil {
		l = m.NewBranch.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 3
	}
	if m.EnableStats {
		n += 3
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Batch {
		n += 3
	}
	return n
}

func (m *InspectJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.BlockState {
		n += 2
	}
	return n
}

func (m *ListJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.InputCommit) > 0 {
		for _, e := range m.InputCommit {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *DeleteJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *StopJobRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *GetLogsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Master {
		n += 2
	}
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Follow {
		n += 2
	}
	return n
}

func (m *LogMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.PipelineName)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Ts != nil {
		l = m.Ts.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.User {
		n += 2
	}
	l = len(m.DatumID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Master {
		n += 2
	}
	return n
}

func (m *RestartDatumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *InspectDatumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *ListDatumRequest) Size() (n int) {
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PageSize != 0 {
		n += 1 + sovPps(uint64(m.PageSize))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	return n
}

func (m *ListDatumResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.DatumInfos) > 0 {
		for _, e := range m.DatumInfos {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.TotalPages != 0 {
		n += 1 + sovPps(uint64(m.TotalPages))
	}
	if m.Page != 0 {
		n += 1 + sovPps(uint64(m.Page))
	}
	return n
}

func (m *CreatePipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ScaleDownThreshold != nil {
		l = m.ScaleDownThreshold.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceSpec != nil {
		l = m.ResourceSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Incremental {
		n += 2
	}
	l = len(m.CacheSize)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.EnableStats {
		n += 3
	}
	if m.Reprocess {
		n += 3
	}
	if m.Batch {
		n += 3
	}
	if m.MaxQueueSize != 0 {
		n += 2 + sovPps(uint64(m.MaxQueueSize))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	return n
}

func (m *InspectPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *ListPipelineRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeletePipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DeleteJobs {
		n += 2
	}
	if m.DeleteRepo {
		n += 2
	}
	if m.All {
		n += 2
	}
	return n
}

func (m *StartPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *StopPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}

func (m *RerunPipelineRequest) Size() (n int) {
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Exclude) > 0 {
		for _, e := range m.Exclude {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Include) > 0 {
		for _, e := range m.Include {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	return n
}

func (m *GarbageCollectRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GarbageCollectResponse) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovPps(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPps(x uint64) (n int) {
	return sovPps(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvVar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &Secret{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdin = append(m.Stdin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptReturnCode = append(m.AcceptReturnCode, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPps
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptReturnCode = append(m.AcceptReturnCode, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptReturnCode", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Debug = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPort", wireType)
			}
			m.InternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalPort", wireType)
			}
			m.ExternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AtomInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AtomInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AtomInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromCommit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromCommit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &google_protobuf1.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Atom", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Atom == nil {
				m.Atom = &AtomInput{}
			}
			if err := m.Atom.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cross", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cross = append(m.Cross, &Input{})
			if err := m.Cross[len(m.Cross)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = append(m.Union, &Input{})
			if err := m.Union[len(m.Union)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cron == nil {
				m.Cron = &CronInput{}
			}
			if err := m.Cron.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &pfs.Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelismSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelismSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelismSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			m.Constant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constant |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coefficient", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Coefficient = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (DatumState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PfsState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PfsState == nil {
				m.PfsState = &pfs.File{}
			}
			if err := m.PfsState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &pfs.FileInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumInfo = append(m.DatumInfo, &DatumInfo{})
			if err := m.DatumInfo[len(m.DatumInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Mean = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stddev", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Stddev = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.FifthPercentile = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NinetyFifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.NinetyFifthPercentile = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &google_protobuf2.Duration{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &google_protobuf2.Duration{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &google_protobuf2.Duration{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			m.DownloadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			m.UploadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &Aggregate{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &Aggregate{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &Aggregate{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadBytes == nil {
				m.DownloadBytes = &Aggregate{}
			}
			if err := m.DownloadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadBytes == nil {
				m.UploadBytes = &Aggregate{}
			}
			if err := m.UploadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &google_protobuf1.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueSize", wireType)
			}
			m.QueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Cpu = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			m.Gpu = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gpu |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentJob == nil {
				m.ParentJob = &Job{}
			}
			if err := m.ParentJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &google_protobuf1.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &google_protobuf1.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (JobState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineVersion", wireType)
			}
			m.PipelineVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputRepo == nil {
				m.OutputRepo = &pfs.Repo{}
			}
			if err := m.OutputRepo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerStatus = append(m.WorkerStatus, &WorkerStatus{})
			if err := m.WorkerStatus[len(m.WorkerStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceSpec == nil {
				m.ResourceSpec = &ResourceSpec{}
			}
			if err := m.ResourceSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBranch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBranch == nil {
				m.NewBranch = &pfs.BranchInfo{}
			}
			if err := m.NewBranch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StatsCommit == nil {
				m.StatsCommit = &pfs.Commit{}
			}
			if err := m.StatsCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Worker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Worker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Worker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (WorkerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobInfo = append(m.JobInfo, &JobInfo{})
			if err := m.JobInfo[len(m.JobInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &pfs.Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &pfs.Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &google_protobuf1.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (PipelineState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobCounts == nil {
				m.JobCounts = make(map[int32]int32)
			}
			var mapkey int32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JobCounts[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDownThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDownThreshold == nil {
				m.ScaleDownThreshold = &google_protobuf2.Duration{}
			}
			if err := m.ScaleDownThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceSpec == nil {
				m.ResourceSpec = &ResourceSpec{}
			}
			if err := m.ResourceSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capability", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capability = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineInfo = append(m.PipelineInfo, &PipelineInfo{})
			if err := m.PipelineInfo[len(m.PipelineInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineVersion", wireType)
			}
			m.PipelineVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineVersion |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputRepo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputRepo == nil {
				m.OutputRepo = &pfs.Repo{}
			}
			if err := m.OutputRepo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentJob == nil {
				m.ParentJob = &Job{}
			}
			if err := m.ParentJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceSpec == nil {
				m.ResourceSpec = &ResourceSpec{}
			}
			if err := m.ResourceSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBranch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewBranch == nil {
				m.NewBranch = &pfs.BranchInfo{}
			}
			if err := m.NewBranch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockState = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputCommit = append(m.InputCommit, &pfs.Commit{})
			if err := m.InputCommit[len(m.InputCommit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ts == nil {
				m.Ts = &google_protobuf1.Timestamp{}
			}
			if err := m.Ts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.User = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumInfos = append(m.DatumInfos, &DatumInfo{})
			if err := m.DatumInfos[len(m.DatumInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPages", wireType)
			}
			m.TotalPages = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalPages |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDownThreshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDownThreshold == nil {
				m.ScaleDownThreshold = &google_protobuf2.Duration{}
			}
			if err := m.ScaleDownThreshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceSpec == nil {
				m.ResourceSpec = &ResourceSpec{}
			}
			if err := m.ResourceSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incremental", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incremental = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableStats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableStats = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reprocess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reprocess = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Batch = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQueueSize", wireType)
			}
			m.MaxQueueSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQueueSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteJobs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteJobs = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteRepo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeleteRepo = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RerunPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RerunPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RerunPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, &pfs.Commit{})
			if err := m.Exclude[len(m.Exclude)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Include", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Include = append(m.Include, &pfs.Commit{})
			if err := m.Include[len(m.Include)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GarbageCollectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GarbageCollectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GarbageCollectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GarbageCollectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GarbageCollectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GarbageCollectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPps(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPps
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPps
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPps
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPps(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPps = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPps   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("client/pps/pps.proto", fileDescriptorPps) }

var fileDescriptorPps = []byte{
	// 3337 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5a, 0x5f, 0x6f, 0xdc, 0xc6,
	0xb5, 0xd7, 0xfe, 0x5f, 0x9e, 0xe5, 0xae, 0x56, 0xa3, 0x3f, 0xa6, 0xd7, 0xb1, 0x24, 0xd3, 0xd7,
	0x8e, 0x6d, 0xe4, 0xca, 0x89, 0x9c, 0xeb, 0x9b, 0x9b, 0xe4, 0x26, 0xd1, 0x3f, 0x1b, 0x92, 0x75,
	0x9d, 0xbd, 0x94, 0x9d, 0xfb, 0x48, 0x70, 0xc9, 0xd9, 0x15, 0x6d, 0x2e, 0xc9, 0x90, 0x5c, 0xd9,
	0xca, 0xd3, 0xfd, 0x06, 0x45, 0xff, 0xa0, 0x28, 0x0a, 0xf4, 0x29, 0x0f, 0x7d, 0xe9, 0x43, 0x3f,
	0x40, 0x5f, 0x0b, 0xe4, 0xa9, 0x28, 0xfa, 0x01, 0x8c, 0xc2, 0xfd, 0x12, 0x7d, 0x29, 0x50, 0xcc,
	0x99, 0x21, 0x97, 0xdc, 0xa5, 0x56, 0x52, 0xdc, 0x07, 0x01, 0x9c, 0x33, 0x67, 0x66, 0xce, 0x9c,
	0x99, 0xf3, 0x3b, 0xbf, 0x39, 0x2b, 0x58, 0x32, 0x1d, 0x9b, 0xba, 0xd1, 0x7d, 0xdf, 0x0f, 0xd9,
	0xdf, 0x86, 0x1f, 0x78, 0x91, 0x47, 0x4a, 0xbe, 0x1f, 0x76, 0xae, 0x0d, 0x3c, 0x6f, 0xe0, 0xd0,
	0xfb, 0x28, 0xea, 0x8d, 0xfa, 0xf7, 0xe9, 0xd0, 0x8f, 0x4e, 0xb9, 0x46, 0x67, 0x6d, 0xb2, 0x33,
	0xb2, 0x87, 0x34, 0x8c, 0x8c, 0xa1, 0x2f, 0x14, 0x56, 0x27, 0x15, 0xac, 0x51, 0x60, 0x44, 0xb6,
	0xe7, 0x8a, 0xfe, 0xa5, 0x81, 0x37, 0xf0, 0xf0, 0xf3, 0x3e, 0xfb, 0x8a, 0xa5, 0xb1, 0x39, 0xfd,
	0x90, 0xfd, 0x71, 0xa9, 0xda, 0x87, 0xea, 0x11, 0x35, 0x03, 0x1a, 0x11, 0x02, 0x65, 0xd7, 0x18,
	0x52, 0xa5, 0xb0, 0x5e, 0xb8, 0x23, 0x69, 0xf8, 0x4d, 0xae, 0x03, 0x0c, 0xbd, 0x91, 0x1b, 0xe9,
	0xbe, 0x11, 0x1d, 0x2b, 0x45, 0xec, 0x91, 0x50, 0xd2, 0x35, 0xa2, 0x63, 0x72, 0x05, 0x6a, 0xd4,
	0x3d, 0xd1, 0x4f, 0x8c, 0x40, 0x29, 0x61, 0x5f, 0x95, 0xba, 0x27, 0xdf, 0x18, 0x01, 0x69, 0x43,
	0xe9, 0x25, 0x3d, 0x55, 0xca, 0x28, 0x64, 0x9f, 0xea, 0x1f, 0x8b, 0x20, 0x3d, 0x0b, 0x0c, 0x37,
	0xec, 0x7b, 0xc1, 0x90, 0x2c, 0x41, 0xc5, 0x1e, 0x1a, 0x83, 0x78, 0x31, 0xde, 0x60, 0xa3, 0xcc,
	0xa1, 0xa5, 0x14, 0xd7, 0x4b, 0x6c, 0x94, 0x39, 0xb4, 0xc8, 0x5d, 0x28, 0x51, 0xf7, 0x44, 0x29,
	0xad, 0x97, 0xee, 0x34, 0x36, 0xaf, 0x6c, 0x30, 0x2f, 0x26, 0x93, 0x6c, 0xec, 0xb9, 0x27, 0x7b,
	0x6e, 0x14, 0x9c, 0x6a, 0x4c, 0x87, 0xdc, 0x82, 0x5a, 0x88, 0x1b, 0x09, 0x95, 0x32, 0xaa, 0x37,
	0x50, 0x9d, 0x6f, 0x4e, 0x8b, 0xfb, 0xd8, 0xca, 0x61, 0x64, 0xd9, 0xae, 0x52, 0xc1, 0x55, 0x78,
	0x83, 0x7c, 0x00, 0xc4, 0x30, 0x4d, 0xea, 0x47, 0x7a, 0x40, 0xa3, 0x51, 0xe0, 0xea, 0xa6, 0x67,
	0x51, 0xa5, 0xba, 0x5e, 0xba, 0x53, 0xd2, 0xda, 0xbc, 0x47, 0xc3, 0x8e, 0x1d, 0xcf, 0xa2, 0x6c,
	0x0e, 0x8b, 0xf6, 0x46, 0x03, 0xa5, 0xb6, 0x5e, 0xb8, 0x53, 0xd7, 0x78, 0x83, 0xcd, 0x81, 0xdb,
	0xd0, 0xfd, 0x91, 0xe3, 0xe8, 0xb1, 0x2d, 0x12, 0x2e, 0xd3, 0xc6, 0x9e, 0xee, 0xc8, 0x71, 0xb8,
	0x3d, 0x61, 0xe7, 0x21, 0xd4, 0x63, 0xfb, 0x63, 0x6f, 0x15, 0x12, 0x6f, 0xb1, 0x15, 0x4e, 0x0c,
	0x67, 0x44, 0x85, 0xcb, 0x79, 0xe3, 0xd3, 0xe2, 0x27, 0x05, 0xb5, 0x03, 0xd5, 0xbd, 0x41, 0x40,
	0xc3, 0x90, 0x8d, 0x7a, 0xae, 0x1d, 0xc6, 0xa3, 0x9e, 0x6b, 0x87, 0xea, 0x75, 0x28, 0x1d, 0x78,
	0x3d, 0xb2, 0x02, 0x45, 0xdb, 0xe2, 0xf2, 0xed, 0xea, 0xdb, 0x37, 0x6b, 0xc5, 0xfd, 0x5d, 0xad,
	0x68, 0x5b, 0xea, 0x11, 0xd4, 0x8e, 0x68, 0x70, 0x62, 0x9b, 0x94, 0xdc, 0x84, 0xa6, 0xed, 0x46,
	0x34, 0x70, 0x0d, 0x47, 0xf7, 0xbd, 0x20, 0x42, 0xed, 0x8a, 0x26, 0xc7, 0xc2, 0xae, 0x17, 0x44,
	0x4c, 0x89, 0xbe, 0x4e, 0x2b, 0x15, 0xb9, 0x52, 0x2c, 0x64, 0x4a, 0xea, 0xef, 0x0a, 0x20, 0x6d,
	0x45, 0xde, 0x70, 0xdf, 0xf5, 0x47, 0xf9, 0x77, 0x88, 0x40, 0x39, 0xa0, 0xbe, 0x27, 0xb6, 0x82,
	0xdf, 0x64, 0x05, 0xaa, 0xbd, 0xc0, 0x70, 0xcd, 0xe3, 0xf8, 0xde, 0xf0, 0x16, 0x93, 0x9b, 0xde,
	0x70, 0x68, 0x47, 0xe2, 0xea, 0x88, 0x16, 0x9b, 0x63, 0xe0, 0x78, 0x3d, 0xa5, 0xc2, 0xe7, 0x60,
	0xdf, 0x4c, 0xe6, 0x18, 0xdf, 0x9d, 0x2a, 0x55, 0x3c, 0x04, 0xfc, 0x26, 0x6b, 0xd0, 0xe8, 0x07,
	0xde, 0x50, 0x17, 0x93, 0xd4, 0x50, 0x1d, 0x98, 0x68, 0x07, 0x25, 0xea, 0x4f, 0x0b, 0x20, 0xed,
	0x04, 0x9e, 0x7b, 0x69, 0x73, 0xc5, 0x8c, 0xa5, 0x49, 0xb3, 0x42, 0x9f, 0x9a, 0xc2, 0x58, 0xfc,
	0x26, 0x1f, 0xb2, 0x0b, 0x66, 0x04, 0x11, 0xda, 0xda, 0xd8, 0xec, 0x6c, 0xf0, 0x60, 0xdd, 0x88,
	0x83, 0x75, 0xe3, 0x59, 0x1c, 0xcd, 0x1a, 0x57, 0x54, 0x7f, 0x5e, 0x80, 0x0a, 0xb7, 0x47, 0x85,
	0xb2, 0x11, 0x79, 0x43, 0xb4, 0xa7, 0xb1, 0xd9, 0xc2, 0x0b, 0x9c, 0x38, 0x57, 0xc3, 0x3e, 0xb2,
	0x0e, 0x15, 0x33, 0xf0, 0xc2, 0x10, 0xc3, 0xa4, 0xb1, 0x09, 0xa8, 0xc4, 0x15, 0x78, 0x07, 0xd3,
	0x18, 0xb9, 0xb6, 0xe7, 0x8a, 0xb0, 0xc9, 0x68, 0x60, 0x07, 0x5b, 0xc7, 0x0c, 0x3c, 0x17, 0xed,
	0x8e, 0xd7, 0x49, 0xbc, 0xa2, 0x61, 0x9f, 0xfa, 0x12, 0xea, 0x07, 0x5e, 0x8f, 0xdb, 0x75, 0x33,
	0xd9, 0x3f, 0xb7, 0xac, 0xb1, 0xc1, 0x00, 0x84, 0xbb, 0x74, 0xea, 0x8c, 0x8a, 0x39, 0x67, 0x54,
	0x4a, 0x9d, 0x51, 0xec, 0xf4, 0xf2, 0xd8, 0xe9, 0xea, 0x73, 0x98, 0xef, 0x1a, 0x81, 0xe1, 0x38,
	0xd4, 0xb1, 0xc3, 0xe1, 0x11, 0xf3, 0x63, 0x07, 0xea, 0xa6, 0xe7, 0x86, 0x91, 0xe1, 0xf2, 0x8b,
	0x57, 0xd6, 0x92, 0x36, 0x59, 0x87, 0x86, 0xe9, 0xd1, 0x7e, 0xdf, 0x36, 0x19, 0xa2, 0xe1, 0xec,
	0x05, 0x2d, 0x2d, 0x3a, 0x28, 0xd7, 0x0b, 0xed, 0xa2, 0xfa, 0x00, 0x24, 0xdc, 0xc0, 0x23, 0xdb,
	0xc1, 0x83, 0x45, 0x14, 0x13, 0xeb, 0xb2, 0x6f, 0x26, 0x3b, 0x36, 0xc2, 0x63, 0x3c, 0x2b, 0x59,
	0xc3, 0x6f, 0xf5, 0x33, 0xa8, 0xec, 0x1a, 0xd1, 0x68, 0x78, 0x56, 0x1c, 0x91, 0x0e, 0x94, 0x5e,
	0x88, 0x7d, 0x36, 0x36, 0xeb, 0xe8, 0xbc, 0x03, 0xaf, 0xa7, 0x31, 0xa1, 0xfa, 0x43, 0x01, 0x24,
	0x1c, 0xbd, 0xef, 0xf6, 0x3d, 0x76, 0x12, 0x16, 0x6b, 0x08, 0xb7, 0xf1, 0x93, 0xc0, 0x6e, 0x8d,
	0x77, 0x90, 0x5b, 0x78, 0x5b, 0x22, 0x1e, 0xe8, 0xad, 0xcd, 0xf9, 0xb1, 0xc6, 0x11, 0x13, 0x6b,
	0xbc, 0x97, 0xbc, 0xcf, 0xd5, 0x42, 0xdc, 0x6a, 0x63, 0x73, 0x01, 0xd5, 0xba, 0x81, 0x67, 0xd2,
	0x30, 0x64, 0x8a, 0x21, 0x57, 0x0c, 0xc9, 0x6d, 0x90, 0xfc, 0x7e, 0xa8, 0xf3, 0x39, 0xf9, 0xf1,
	0x4a, 0x78, 0x58, 0xcc, 0x05, 0x5a, 0xdd, 0xef, 0xa3, 0x3a, 0x25, 0x37, 0xa0, 0x6c, 0x19, 0x91,
	0x81, 0x28, 0xd8, 0xd8, 0x6c, 0x26, 0x2a, 0xcc, 0x6c, 0x0d, 0xbb, 0xd4, 0xcf, 0x00, 0x92, 0x9d,
	0x84, 0xe4, 0xdf, 0x01, 0xd0, 0x62, 0xdd, 0x76, 0xfb, 0x9e, 0x52, 0xc0, 0x61, 0xad, 0xb1, 0xb5,
	0x38, 0x4e, 0xb2, 0xe2, 0x4f, 0xf5, 0xf7, 0x0c, 0x16, 0x06, 0x83, 0x80, 0x0e, 0xd8, 0x6a, 0x4b,
	0x50, 0x31, 0x59, 0xd2, 0x40, 0x3f, 0x94, 0x34, 0xde, 0x60, 0xce, 0x1f, 0x52, 0xc3, 0xc5, 0xad,
	0x17, 0x34, 0xfc, 0x66, 0x91, 0x16, 0x46, 0x96, 0x45, 0x4f, 0xc4, 0xa1, 0x8a, 0x16, 0xb9, 0x0b,
	0xed, 0xbe, 0xdd, 0x8f, 0x8e, 0x75, 0x9f, 0x06, 0x26, 0x75, 0x23, 0xdb, 0xe1, 0xdb, 0x2b, 0x68,
	0xf3, 0x28, 0xef, 0x26, 0x62, 0xf2, 0x10, 0xae, 0xb8, 0xb6, 0x4b, 0xa3, 0x53, 0x7d, 0x6a, 0x44,
	0x05, 0x47, 0x2c, 0xf3, 0xee, 0x47, 0xd9, 0x71, 0xea, 0xcf, 0x8a, 0x20, 0xa7, 0x5d, 0x4a, 0xbe,
	0x80, 0xa6, 0xe5, 0xbd, 0x72, 0x1d, 0xcf, 0xb0, 0x74, 0x96, 0x82, 0xc5, 0x29, 0x5e, 0x9d, 0x8a,
	0xe8, 0x5d, 0x91, 0x7e, 0x35, 0x39, 0xd6, 0x67, 0x31, 0x4e, 0x3e, 0x07, 0xd9, 0xe7, 0xf3, 0xf1,
	0xe1, 0xc5, 0xf3, 0x86, 0x37, 0x84, 0x3a, 0x8e, 0xfe, 0x14, 0x1a, 0x23, 0x7f, 0xbc, 0x76, 0xe9,
	0xbc, 0xc1, 0xc0, 0xb5, 0x71, 0xec, 0x2d, 0x68, 0x25, 0x96, 0xf7, 0x4e, 0x23, 0x1a, 0xa2, 0xaf,
	0xca, 0x5a, 0xb2, 0x9f, 0x6d, 0x26, 0x24, 0x37, 0x40, 0x16, 0x4b, 0x70, 0xa5, 0x0a, 0x2a, 0x89,
	0x65, 0x51, 0x45, 0xfd, 0x75, 0x11, 0x96, 0x93, 0x73, 0xcc, 0x78, 0xe7, 0x41, 0xbe, 0x77, 0x04,
	0x68, 0xc5, 0x43, 0x26, 0x5c, 0xf2, 0x51, 0xae, 0x4b, 0x26, 0xc7, 0x64, 0xfc, 0x70, 0x3f, 0xcf,
	0x0f, 0x93, 0x23, 0xd2, 0x9b, 0xff, 0x8f, 0xdc, 0xcd, 0x4f, 0x8f, 0x99, 0x70, 0xc6, 0x47, 0x39,
	0xce, 0xc8, 0x31, 0x2d, 0xed, 0x9c, 0x7f, 0x14, 0x40, 0xfe, 0x3f, 0x2f, 0x78, 0x49, 0x03, 0xe6,
	0x92, 0x51, 0x48, 0xee, 0x82, 0xf4, 0x0a, 0xdb, 0x7a, 0x02, 0x1c, 0xf2, 0xdb, 0x37, 0x6b, 0x75,
	0xae, 0xb4, 0xbf, 0xab, 0xd5, 0x79, 0xf7, 0xbe, 0x45, 0xd6, 0xa1, 0xfa, 0xc2, 0xeb, 0x31, 0x3d,
	0xc4, 0xcb, 0x6d, 0xe9, 0xed, 0x9b, 0xb5, 0x0a, 0x03, 0xdc, 0x5d, 0xad, 0xf2, 0xc2, 0xeb, 0xed,
	0x5b, 0x0c, 0xa4, 0x31, 0x44, 0x4b, 0xa9, 0x58, 0x4b, 0xd0, 0x8c, 0xc7, 0x28, 0xf9, 0x18, 0x6a,
	0x98, 0x43, 0xa8, 0x25, 0x36, 0x39, 0x2b, 0xdd, 0xc4, 0xaa, 0x63, 0x34, 0xa9, 0x9c, 0x83, 0x26,
	0xd7, 0x01, 0xbe, 0x1d, 0xd1, 0x11, 0xd5, 0x43, 0xfb, 0x3b, 0x8a, 0x89, 0xb6, 0xa4, 0x49, 0x28,
	0x39, 0xb2, 0xbf, 0xa3, 0xea, 0x01, 0xc8, 0x1a, 0x0d, 0xbd, 0x51, 0x60, 0x52, 0x84, 0x6c, 0xc6,
	0xdf, 0xfc, 0x11, 0x6e, 0xbc, 0xa8, 0xb1, 0x4f, 0x16, 0xce, 0x43, 0x3a, 0xf4, 0x82, 0x53, 0x91,
	0x15, 0x44, 0x8b, 0x69, 0x0e, 0xfc, 0x11, 0x1e, 0x66, 0x49, 0x63, 0x9f, 0xea, 0x6f, 0x25, 0xa8,
	0x61, 0xbe, 0xe9, 0x7b, 0x31, 0xc0, 0x16, 0x72, 0x00, 0x96, 0x7c, 0x00, 0x52, 0x14, 0x33, 0xc0,
	0xcc, 0xf5, 0x49, 0x78, 0xa1, 0x36, 0x56, 0x20, 0x77, 0xa1, 0xee, 0xdb, 0x3e, 0x75, 0x6c, 0x37,
	0xbe, 0x39, 0x4d, 0xbe, 0x59, 0x21, 0xd4, 0x92, 0x6e, 0xf2, 0x3e, 0x80, 0x6f, 0x04, 0xd4, 0x8d,
	0x74, 0xb6, 0x76, 0x75, 0x62, 0x6d, 0x89, 0xf7, 0x31, 0x7a, 0x95, 0xf2, 0x79, 0xed, 0xe2, 0x3e,
	0x7f, 0x08, 0xf5, 0xbe, 0xed, 0xda, 0xe1, 0x31, 0xb5, 0x94, 0xfa, 0xb9, 0xc3, 0x12, 0x5d, 0xf2,
	0x21, 0x34, 0xbd, 0x51, 0xe4, 0x8f, 0xa2, 0x98, 0xd3, 0x48, 0xd3, 0x19, 0x58, 0xe6, 0x1a, 0xbc,
	0x45, 0x6e, 0xc6, 0x29, 0x05, 0x30, 0xa5, 0x34, 0xe3, 0x3d, 0x64, 0x12, 0xca, 0x97, 0xd0, 0xf6,
	0xc7, 0x09, 0x57, 0x47, 0x16, 0x23, 0xe3, 0xcc, 0x4b, 0xdc, 0x41, 0xd9, 0x6c, 0xac, 0xcd, 0xfb,
	0x13, 0xe9, 0xf9, 0x2e, 0xb4, 0x63, 0xd7, 0xe9, 0x27, 0x34, 0x08, 0x19, 0xdf, 0x68, 0x22, 0x7e,
	0xcc, 0xc7, 0xf2, 0x6f, 0xb8, 0x98, 0xdc, 0x66, 0xcc, 0x1c, 0x79, 0xa7, 0xd2, 0xc2, 0x25, 0x64,
	0xc1, 0xcc, 0x51, 0xa6, 0xc5, 0x9d, 0x8c, 0x65, 0x50, 0xa4, 0xb6, 0xca, 0x7c, 0xbc, 0x47, 0x3f,
	0xdc, 0xe0, 0x6c, 0x57, 0x13, 0x5d, 0x8c, 0x94, 0x0a, 0x7f, 0x08, 0x02, 0xb9, 0x80, 0x17, 0x4b,
	0xb8, 0x60, 0x9b, 0xd3, 0xc8, 0x7b, 0xd0, 0x10, 0x4a, 0x48, 0xe5, 0x48, 0x2a, 0x0f, 0x6a, 0xd4,
	0xf7, 0x34, 0xe0, 0xbd, 0xec, 0x9b, 0x28, 0x50, 0x0b, 0x28, 0x67, 0x6c, 0x4b, 0x68, 0x7f, 0xdc,
	0x44, 0x14, 0x35, 0x22, 0x43, 0x17, 0x68, 0x44, 0x2d, 0x65, 0x05, 0xef, 0x6b, 0x93, 0x49, 0xbb,
	0xb1, 0x90, 0x05, 0x09, 0xaa, 0x45, 0x5e, 0x64, 0x38, 0xca, 0x15, 0x1e, 0x24, 0x4c, 0xf2, 0x8c,
	0x09, 0xc8, 0x43, 0x68, 0x0a, 0x4c, 0x08, 0x11, 0x24, 0x14, 0x05, 0xe3, 0x99, 0x07, 0x5d, 0x1a,
	0x3d, 0x34, 0xf9, 0x55, 0x1a, 0x4b, 0x1e, 0x42, 0x33, 0x10, 0xc1, 0xc5, 0x8f, 0xe7, 0x6a, 0x2a,
	0x58, 0xd3, 0x61, 0xa7, 0xc9, 0x41, 0x3a, 0x08, 0xd7, 0xa1, 0x62, 0x33, 0x94, 0x50, 0x3a, 0x29,
	0xce, 0x21, 0xd8, 0x1f, 0x76, 0x90, 0x0d, 0x00, 0x97, 0xbe, 0x8a, 0xfd, 0x77, 0x0d, 0xd5, 0xe6,
	0xd1, 0x39, 0xdc, 0x7d, 0x3c, 0x97, 0xbb, 0xf4, 0x95, 0xf0, 0xe6, 0x3a, 0x34, 0x6c, 0xd7, 0x0c,
	0xe8, 0x90, 0xba, 0x6c, 0x87, 0xef, 0x21, 0x97, 0x4b, 0x8b, 0xc8, 0x06, 0xc8, 0x08, 0x18, 0xf1,
	0x1d, 0xbd, 0x3e, 0x7d, 0x47, 0x1b, 0xa8, 0x20, 0xae, 0xe8, 0x0d, 0x90, 0xd1, 0x65, 0xe1, 0x4b,
	0xdb, 0xf7, 0xa9, 0xa5, 0xac, 0xa2, 0xd3, 0x1a, 0x4c, 0x76, 0xc4, 0x45, 0x63, 0x8c, 0x5a, 0x3b,
	0x07, 0xa3, 0x6e, 0x80, 0x4c, 0x5d, 0xa3, 0xe7, 0x50, 0x9d, 0xeb, 0xaf, 0x73, 0xf3, 0xb8, 0x8c,
	0xa7, 0x2a, 0x46, 0xd3, 0x0d, 0x27, 0x52, 0x6e, 0x08, 0x9a, 0x6e, 0x38, 0x11, 0xa3, 0x24, 0x3d,
	0x23, 0x32, 0x8f, 0x15, 0x95, 0xbf, 0xe1, 0xb0, 0xc1, 0xf0, 0x2a, 0xa0, 0x46, 0xe8, 0xb9, 0xca,
	0x4d, 0x8e, 0x57, 0xbc, 0x75, 0x50, 0xae, 0x97, 0xdb, 0x95, 0x83, 0x72, 0xbd, 0xd2, 0xae, 0xaa,
	0xbb, 0x50, 0xe5, 0xc7, 0x96, 0xfb, 0x7c, 0xb8, 0x9d, 0x25, 0x74, 0xed, 0x89, 0x63, 0x8e, 0x03,
	0x50, 0x7d, 0x20, 0xe8, 0x35, 0xe3, 0x56, 0xef, 0x43, 0x1d, 0x73, 0xc1, 0x98, 0x59, 0xc9, 0x71,
	0xd0, 0xe2, 0x59, 0xd4, 0x5e, 0xf0, 0x0f, 0x75, 0x15, 0xea, 0x31, 0x72, 0xe5, 0x2d, 0xae, 0x7e,
	0x5f, 0x80, 0x66, 0xac, 0xc0, 0x99, 0xfb, 0x75, 0xf1, 0x9a, 0x29, 0x4c, 0x86, 0xc0, 0xe4, 0x3b,
	0xac, 0x98, 0x79, 0x87, 0xc5, 0x5c, 0xbe, 0x94, 0xc3, 0xe5, 0xcb, 0x39, 0x5c, 0xbe, 0x92, 0xf2,
	0xc0, 0x1a, 0x94, 0xd9, 0x83, 0x4b, 0x40, 0x68, 0xe6, 0x12, 0x60, 0x87, 0xfa, 0x8b, 0x3a, 0xc8,
	0x63, 0x2b, 0xfb, 0x5e, 0x06, 0xa5, 0x0b, 0xb3, 0x51, 0xfa, 0x72, 0xf0, 0xff, 0x5f, 0x00, 0x66,
	0x40, 0x8d, 0x88, 0x5a, 0xba, 0x11, 0x09, 0x83, 0x66, 0xc1, 0xae, 0x24, 0xb4, 0xb7, 0x22, 0x72,
	0x27, 0x3e, 0xc7, 0x1a, 0x9e, 0x23, 0xc9, 0x18, 0x94, 0x81, 0xd2, 0x1b, 0x20, 0x07, 0x94, 0x91,
	0x48, 0x9d, 0x06, 0x81, 0x17, 0x20, 0xba, 0x4b, 0x5a, 0x83, 0xcb, 0xf6, 0x98, 0x88, 0x7c, 0x09,
	0xc0, 0x0e, 0x18, 0x69, 0x2f, 0x2f, 0x09, 0x34, 0x36, 0xd7, 0x33, 0x33, 0x32, 0x3f, 0xb0, 0xf3,
	0xde, 0x41, 0x15, 0x5e, 0xd6, 0x90, 0x5e, 0xc4, 0xed, 0x5c, 0xb8, 0x86, 0xcb, 0xc0, 0xb5, 0x02,
	0xb5, 0x18, 0xa5, 0x1b, 0x1c, 0xe5, 0x44, 0xf3, 0x47, 0xa2, 0x6e, 0x3b, 0x07, 0x75, 0xf9, 0x7b,
	0x69, 0x61, 0xea, 0xbd, 0xf4, 0x04, 0x96, 0x42, 0xd3, 0x70, 0xa8, 0xce, 0x08, 0x97, 0x1e, 0x1d,
	0x07, 0x34, 0x3c, 0xf6, 0x1c, 0x4b, 0xc0, 0xf2, 0x0c, 0x4a, 0x4b, 0x70, 0xd8, 0xae, 0xf7, 0xca,
	0x7d, 0x16, 0x0f, 0x9a, 0x86, 0xc5, 0xc5, 0x4b, 0xc2, 0xe2, 0xd2, 0x59, 0xb0, 0xb8, 0x0e, 0x0d,
	0x8b, 0x86, 0x66, 0x60, 0xfb, 0x6c, 0x71, 0x65, 0x99, 0x1f, 0x63, 0x4a, 0x34, 0x09, 0x84, 0x2b,
	0xd3, 0x40, 0x78, 0x1d, 0xc0, 0x34, 0xcc, 0x63, 0x41, 0x98, 0xae, 0xf0, 0x7a, 0x19, 0x4a, 0x18,
	0x61, 0x9a, 0xc2, 0x2a, 0xe5, 0x6c, 0xac, 0xba, 0x9a, 0xc2, 0xaa, 0x55, 0x36, 0xab, 0x6f, 0xf4,
	0x6c, 0xc7, 0x8e, 0x4e, 0x11, 0xd7, 0x25, 0x2d, 0x25, 0x19, 0x63, 0xd9, 0xb5, 0x7c, 0x2c, 0x7b,
	0x2f, 0x8d, 0x65, 0xe4, 0xdf, 0xa0, 0x35, 0x34, 0x5e, 0xeb, 0x29, 0x62, 0x77, 0x1d, 0xe1, 0x57,
	0x1e, 0x1a, 0xaf, 0xff, 0x37, 0xe6, 0x76, 0xe9, 0xa4, 0xbd, 0x3a, 0x23, 0x69, 0x77, 0x3e, 0x87,
	0x56, 0xf6, 0xda, 0xa6, 0xab, 0x59, 0x95, 0x9c, 0x6a, 0x56, 0x25, 0x55, 0xcd, 0x3a, 0x28, 0xd7,
	0x4b, 0xed, 0x32, 0x47, 0x57, 0xf5, 0x71, 0x1a, 0xbb, 0x18, 0x2c, 0x3e, 0x84, 0x66, 0x42, 0x31,
	0x52, 0xd8, 0xb8, 0x30, 0x15, 0x38, 0x9a, 0xec, 0xa7, 0x5a, 0xea, 0xf7, 0x15, 0x68, 0xef, 0x60,
	0x20, 0x33, 0xe6, 0x46, 0xbf, 0x1d, 0xd1, 0x30, 0xca, 0x02, 0x47, 0xe1, 0x32, 0xbc, 0xb1, 0x38,
	0x1b, 0x91, 0xf2, 0x42, 0xb3, 0x76, 0x99, 0xd0, 0x4c, 0x79, 0xba, 0x7e, 0x31, 0x7a, 0x24, 0x9d,
	0x1d, 0xa8, 0x79, 0xb4, 0x0c, 0xf2, 0x69, 0xd9, 0x54, 0x4c, 0x37, 0xce, 0x67, 0x52, 0xf2, 0x2c,
	0x26, 0x95, 0x65, 0xd0, 0xcd, 0xb3, 0x19, 0xf4, 0x54, 0x0c, 0xb7, 0x2e, 0x19, 0xc3, 0xf3, 0x17,
	0xa3, 0x36, 0xed, 0xcb, 0x52, 0x9b, 0x85, 0xe9, 0x88, 0x9e, 0x0c, 0x59, 0x72, 0x76, 0xc8, 0x2e,
	0xe6, 0xd1, 0x8b, 0xa5, 0x54, 0x48, 0x66, 0xae, 0x7b, 0x17, 0x16, 0xf6, 0x5d, 0xb6, 0xfb, 0x28,
	0x75, 0x4b, 0x67, 0xbd, 0x7c, 0xd6, 0xa0, 0xd1, 0x73, 0x3c, 0xf3, 0xa5, 0x3e, 0xe6, 0x17, 0x75,
	0x0d, 0x50, 0x84, 0xf9, 0x48, 0xfd, 0x4d, 0x01, 0x5a, 0x87, 0x76, 0x98, 0x9e, 0xef, 0x12, 0x99,
	0x75, 0x03, 0x64, 0xf4, 0x61, 0xcc, 0xe1, 0x8a, 0x71, 0x11, 0x3d, 0xc5, 0xe1, 0x50, 0x41, 0x70,
	0xb8, 0xa9, 0x87, 0x49, 0xe9, 0x9c, 0x87, 0x89, 0xba, 0x01, 0xed, 0x5d, 0xea, 0xd0, 0x4c, 0x58,
	0xce, 0xd8, 0xb0, 0xfa, 0x01, 0xb4, 0x8e, 0x22, 0xcf, 0xbf, 0xa0, 0xf6, 0x5f, 0x0a, 0xd0, 0x7a,
	0x4c, 0xa3, 0x43, 0x6f, 0x10, 0x5e, 0xc4, 0x9b, 0x97, 0x88, 0xf0, 0x98, 0xad, 0xf6, 0x6d, 0x27,
	0xa2, 0x41, 0x88, 0x0f, 0x72, 0x89, 0xb3, 0xd5, 0x47, 0x5c, 0x84, 0xef, 0x5c, 0x23, 0x8c, 0x68,
	0x80, 0x4c, 0xa8, 0xae, 0x89, 0xd6, 0xb8, 0x00, 0x58, 0x3d, 0xab, 0x00, 0xb8, 0x02, 0xd5, 0xbe,
	0xe7, 0x38, 0xde, 0x2b, 0xf1, 0x63, 0x82, 0x68, 0x89, 0x4b, 0xf2, 0x87, 0x22, 0xc0, 0xa1, 0x37,
	0xf8, 0x1f, 0x1a, 0x86, 0xc6, 0x00, 0xcb, 0xf6, 0x49, 0x74, 0xa7, 0xc8, 0x5f, 0x02, 0x7f, 0x4f,
	0x19, 0xff, 0x1a, 0x57, 0x16, 0x4a, 0xe7, 0x54, 0x16, 0xca, 0x33, 0x2a, 0x0b, 0xf7, 0xa0, 0x98,
	0x14, 0x08, 0x66, 0x51, 0xa6, 0x62, 0x14, 0x32, 0x72, 0x31, 0xe4, 0x16, 0xe2, 0x3e, 0x25, 0x2d,
	0x6e, 0x66, 0x0b, 0x22, 0xb5, 0x99, 0x05, 0x11, 0x02, 0xe5, 0x51, 0x48, 0x39, 0x7d, 0xaa, 0x6b,
	0xf8, 0x4d, 0x6e, 0x43, 0x5d, 0x14, 0x1d, 0x2d, 0x04, 0x3d, 0x69, 0xbb, 0xf1, 0xf6, 0xcd, 0x5a,
	0x8d, 0x57, 0x1c, 0x77, 0xb5, 0x1a, 0xaf, 0x37, 0x5a, 0x29, 0xf7, 0x43, 0xda, 0xfd, 0xea, 0x33,
	0x58, 0xd4, 0xf8, 0x63, 0x8e, 0xfb, 0xfc, 0x02, 0xf7, 0x62, 0xf2, 0xb0, 0x8b, 0x53, 0x87, 0xad,
	0xfe, 0x27, 0x2c, 0x8a, 0xc8, 0xcd, 0xcc, 0x7a, 0x6e, 0xb1, 0x57, 0xd5, 0xa1, 0xcd, 0xe2, 0xf3,
	0xc2, 0xb6, 0x5c, 0x03, 0xc9, 0x37, 0x06, 0x22, 0x49, 0x17, 0x31, 0x49, 0xd7, 0x99, 0x00, 0x13,
	0x34, 0x96, 0xb3, 0x07, 0x54, 0xd4, 0x50, 0xf0, 0x5b, 0x3d, 0x85, 0x85, 0xd4, 0x02, 0xa1, 0xef,
	0xb9, 0x21, 0x16, 0xd0, 0xc6, 0x95, 0xdb, 0xf0, 0x8c, 0xd2, 0x2d, 0x58, 0xe3, 0x52, 0xef, 0x1a,
	0x34, 0xf0, 0x2d, 0xab, 0xb3, 0x39, 0x43, 0xb1, 0x30, 0xa0, 0xa8, 0xcb, 0x24, 0xb9, 0x4b, 0xff,
	0xa9, 0x02, 0xcb, 0x3c, 0xe9, 0x26, 0x11, 0x74, 0x79, 0x0c, 0xba, 0x1c, 0xbb, 0x5f, 0x81, 0xea,
	0xc8, 0xb7, 0x18, 0x16, 0x8a, 0xa0, 0xe3, 0xad, 0x77, 0xcf, 0xc8, 0x17, 0xca, 0xb4, 0x53, 0xe9,
	0x13, 0x72, 0xd2, 0xe7, 0x59, 0xd4, 0xb7, 0xf1, 0x2f, 0xa1, 0xbe, 0xf2, 0x25, 0xd3, 0x66, 0xf3,
	0x82, 0xd4, 0xb7, 0x75, 0x2e, 0xf5, 0x9d, 0x3f, 0x8f, 0xfa, 0xb6, 0xcf, 0xa3, 0xbe, 0x0b, 0xd3,
	0x79, 0xf4, 0x3d, 0x90, 0x02, 0x2a, 0x8a, 0x2d, 0x22, 0xcf, 0x8e, 0x05, 0xe3, 0x8c, 0xba, 0x98,
	0x26, 0xb9, 0xd3, 0x64, 0x76, 0x69, 0x36, 0x99, 0x5d, 0x9e, 0x41, 0xb1, 0x32, 0xf9, 0x79, 0x07,
	0x56, 0x44, 0x94, 0xff, 0xf8, 0x0b, 0xad, 0x2e, 0xc3, 0x22, 0x0b, 0xc8, 0x89, 0x19, 0xd4, 0x5f,
	0x16, 0x60, 0x99, 0xa7, 0xc2, 0x77, 0x08, 0x96, 0x35, 0x76, 0x68, 0x6c, 0x0e, 0x46, 0xb7, 0xc2,
	0x98, 0x0f, 0x58, 0x71, 0x86, 0x0d, 0x53, 0x0a, 0xc8, 0xdd, 0x4a, 0x69, 0x05, 0x24, 0x6c, 0x6d,
	0x28, 0x19, 0x8e, 0x23, 0x1e, 0xf4, 0xec, 0x53, 0xdd, 0x82, 0xa5, 0x23, 0x06, 0x97, 0xef, 0xb0,
	0xe5, 0xaf, 0x60, 0x91, 0x65, 0xed, 0x77, 0x98, 0xe1, 0x27, 0x05, 0x58, 0xd2, 0x68, 0x30, 0x72,
	0xdf, 0xc1, 0x39, 0xb7, 0xa0, 0x46, 0x5f, 0x9b, 0xce, 0xc8, 0xa2, 0x79, 0x44, 0x26, 0xee, 0x63,
	0x6a, 0xb6, 0xcb, 0xd5, 0x4a, 0x39, 0x6a, 0xa2, 0x4f, 0xbd, 0x02, 0xcb, 0x8f, 0x8d, 0xa0, 0x67,
	0x0c, 0xe8, 0x8e, 0xe7, 0x38, 0xd4, 0x8c, 0xe2, 0x83, 0x54, 0x60, 0x65, 0xb2, 0x83, 0xa3, 0xee,
	0x3d, 0x1d, 0xeb, 0x3b, 0xfc, 0xc7, 0xb6, 0x36, 0xc8, 0x07, 0x5f, 0x6f, 0xeb, 0x47, 0xcf, 0xb6,
	0xb4, 0x67, 0xfb, 0x4f, 0x1f, 0xb7, 0xe7, 0xc8, 0x3c, 0x34, 0x98, 0x44, 0x7b, 0xfe, 0xf4, 0x29,
	0x13, 0x14, 0x62, 0xc1, 0xa3, 0xad, 0xfd, 0xc3, 0xe7, 0xda, 0x5e, 0xbb, 0x18, 0x0b, 0x8e, 0x9e,
	0xef, 0xec, 0xec, 0x1d, 0x1d, 0xb5, 0x4b, 0xa4, 0x05, 0xc0, 0x04, 0x4f, 0xf6, 0x0f, 0x0f, 0xf7,
	0x76, 0xdb, 0xe5, 0x7b, 0x5f, 0x89, 0x9f, 0xe7, 0xf8, 0x12, 0x00, 0x55, 0x36, 0x76, 0x6f, 0xb7,
	0x3d, 0x47, 0x1a, 0x50, 0x8b, 0x87, 0x15, 0xb0, 0xf1, 0x64, 0xbf, 0xdb, 0xdd, 0xdb, 0x6d, 0x17,
	0x89, 0x0c, 0xf5, 0xc4, 0x88, 0xd2, 0xbd, 0x2f, 0xa1, 0x91, 0x2a, 0x4c, 0xb1, 0x15, 0xbb, 0x5f,
	0xef, 0x26, 0x36, 0xcd, 0xc5, 0x82, 0xf1, 0x5c, 0x2d, 0x00, 0x26, 0x10, 0x0b, 0x15, 0xef, 0xfd,
	0x7f, 0xaa, 0xdc, 0xc4, 0xe7, 0x58, 0x86, 0x85, 0xee, 0x7e, 0x77, 0xef, 0x70, 0xff, 0xe9, 0x5e,
	0x7a, 0xbb, 0x4b, 0xd0, 0x4e, 0xc4, 0xe3, 0x3d, 0x5f, 0x81, 0xc5, 0xb1, 0x74, 0x2f, 0x51, 0x2f,
	0x66, 0xd4, 0x63, 0x8f, 0x94, 0xc8, 0x22, 0xcc, 0x27, 0xd2, 0xee, 0xd6, 0xf3, 0x23, 0xe6, 0x85,
	0xcd, 0xbf, 0xd7, 0xa1, 0xb4, 0xd5, 0xdd, 0x27, 0x1b, 0x20, 0x25, 0x4f, 0x3e, 0xb2, 0x2c, 0x7e,
	0xd0, 0xce, 0x3e, 0x01, 0x3b, 0x49, 0x76, 0x55, 0xe7, 0xc8, 0xc7, 0x00, 0x63, 0xf6, 0x4d, 0x56,
	0x04, 0x24, 0x4e, 0xd0, 0xf1, 0x4e, 0xa6, 0x0c, 0xa7, 0xce, 0x91, 0xfb, 0x50, 0x13, 0x04, 0x9b,
	0x2c, 0x62, 0x57, 0x96, 0x6e, 0x77, 0x9a, 0x69, 0xfd, 0x50, 0x9d, 0x23, 0x9f, 0x83, 0x94, 0x50,
	0x5e, 0x61, 0xd6, 0x24, 0x05, 0xee, 0xac, 0x4c, 0x65, 0x81, 0xbd, 0xa1, 0x1f, 0x9d, 0xaa, 0x73,
	0xe4, 0x13, 0xa8, 0x09, 0x02, 0x2c, 0x96, 0xcb, 0xd2, 0xe1, 0x19, 0x23, 0x3f, 0x05, 0x39, 0x4d,
	0x51, 0x88, 0x92, 0xde, 0x60, 0x9a, 0x7f, 0x74, 0x26, 0x88, 0x00, 0xb7, 0x39, 0x21, 0x11, 0xc2,
	0xe6, 0x49, 0xd6, 0xd2, 0x59, 0x99, 0x14, 0xf3, 0x5b, 0xaf, 0xce, 0x91, 0x6d, 0xfc, 0x4d, 0x28,
	0xa1, 0x5c, 0x62, 0xe5, 0x1c, 0x16, 0x36, 0xc3, 0xfa, 0x47, 0xd0, 0xca, 0x52, 0x09, 0xd2, 0x49,
	0x9d, 0xe8, 0x04, 0x2a, 0xcc, 0x98, 0x67, 0x07, 0xe6, 0x27, 0x20, 0x9c, 0x5c, 0x4b, 0x3b, 0x62,
	0x72, 0xa6, 0xe9, 0xca, 0x82, 0x3a, 0x47, 0xbe, 0x00, 0x39, 0x0d, 0xe1, 0x62, 0x43, 0x39, 0xa8,
	0xde, 0x21, 0x53, 0xc3, 0x43, 0xbe, 0x99, 0x2c, 0xd4, 0x8b, 0xcd, 0xe4, 0xe2, 0xff, 0x8c, 0xcd,
	0xec, 0x42, 0x33, 0x03, 0xcd, 0xe4, 0xaa, 0xb8, 0x12, 0xd3, 0x70, 0x3d, 0x63, 0x96, 0x6d, 0x90,
	0xd3, 0xe8, 0x2c, 0x76, 0x93, 0x03, 0xd8, 0xb3, 0x2d, 0xc9, 0xc0, 0xb3, 0xb0, 0x24, 0x0f, 0xb2,
	0x67, 0xcc, 0xf2, 0xdf, 0x71, 0x68, 0x6c, 0x39, 0x0e, 0x39, 0x43, 0x6d, 0xc6, 0xf0, 0x07, 0x50,
	0x13, 0xaf, 0x3d, 0x11, 0x1b, 0xd9, 0xb7, 0x5f, 0x87, 0xff, 0x27, 0xc5, 0xf8, 0xed, 0xa4, 0xce,
	0x7d, 0x58, 0x20, 0x4f, 0xa0, 0x95, 0x85, 0x6b, 0x71, 0x16, 0xb9, 0xe0, 0xde, 0xb9, 0x96, 0xdb,
	0x17, 0xdf, 0xf4, 0xed, 0xf6, 0x0f, 0x6f, 0x57, 0x0b, 0x7f, 0x7e, 0xbb, 0x5a, 0xf8, 0xeb, 0xdb,
	0xd5, 0xc2, 0xaf, 0xfe, 0xb6, 0x3a, 0xd7, 0xab, 0xa2, 0x95, 0x0f, 0xfe, 0x19, 0x00, 0x00, 0xff,
	0xff, 0x7f, 0x2c, 0x69, 0x2a, 0xf9, 0x27, 0x00, 0x00,
}
