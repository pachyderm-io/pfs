package load

import (
	"math/rand"
)

// FuzzOperationSpec specifies a single operation done during a fuzz test,
// including the type of operation that may be performed (PutFile, DeleteFile)
// and the probability of the fuzz test performing this operation.
type FuzzOperationSpec struct {
	// OperationSpec specifies the type of operation (PutFile, DeleteFile) and
	// its type-dependent parameters
	OperationSpec *OperationSpec `yaml:"operation,omitempty"`

	// Prob is the probability of this FuzzOperation being executed
	Prob float64 `yaml:"prob,omitempty"`
}

// FuzzOperation scans the operations in 'specs' and stochastically performs (or
// skips) each operation, in line with its spec, on 'repo'@'commit'
func FuzzOperation(env *Env, repo, commit string, specs []*FuzzOperationSpec) error {
	var totalProb float64
	prob := rand.Float64()
	for _, spec := range specs {
		totalProb += spec.Prob
		if prob <= totalProb {
			return Operation(env, repo, commit, spec.OperationSpec)
		}
	}
	// TODO: Should not reach here, need to validate fuzzing probabilities (this applies to other fuzzers as well).
	return nil
}

// FuzzFileSpec specifies an individual files that the fuzzer should put in a
// Pachyderm commit during a fuzz-generated PutFile operation. FuzzFile will
// choose this spec with probability 'Prob'.
type FuzzFileSpec struct {
	// FileSpec specifies the file(s) generated by this FileSpec
	FileSpec *FileSpec `yaml:"file,omitempty"`

	// Prob is the probability that this FuzzFileSpec is chosen by FuzzFiles.
	Prob float64 `yaml:"prob,omitempty"`
}

// FuzzFile chooses a random FuzzFileSpec from 'specs' (choosing 'specs[i]' with
// probability 'specs[i].Prob') and then generates and returns a file based on
// that spec.
func FuzzFile(env *Env, specs []*FuzzFileSpec) (*MemFile, error) {
	var totalProb float64
	prob := rand.Float64()
	for _, spec := range specs {
		totalProb += spec.Prob
		if prob <= totalProb {
			return File(env, spec.FileSpec)
		}
	}
	return nil, nil
}

// FuzzSizeSpec specifies a size range for a single file. FuzzSize will choose
// this FuzzSizeSpec with probability 'Prob'.
type FuzzSizeSpec struct {
	// SizeSpec specifies the way that FuzzSize will generate a size, if this
	// FuzzSizeSpec is chosen.
	SizeSpec *SizeSpec `yaml:"size,omitempty"`

	// Prob is the probability that this FuzzSizeSpec is chosen by FuzzSize.
	Prob float64 `yaml:"prob,omitempty"`
}

// FuzzSize scans 'specs' and returns the ith SizeSpec with probability equal to
// sum{spec[j].Prob | j <= i}.
func FuzzSize(specs []*FuzzSizeSpec) *SizeSpec {
	var totalProb float64
	prob := rand.Float64()
	for _, spec := range specs {
		totalProb += spec.Prob
		if prob <= totalProb {
			return spec.SizeSpec
		}
	}
	return nil
}
