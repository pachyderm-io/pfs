package load

import (
	"context"
	"path"

	"github.com/pachyderm/pachyderm/v2/src/client"
)

// OperationsSpec configures the operations generated by Operations() during
// fuzzing.
type OperationsSpec struct {
	// Count specifies the number of operations that Operations() will perform.
	Count int `yaml:"count,omitempty"`

	// FuzzOperationSpecs specify the possible FuzzOperations that might be
	// performed by each iteration of Operations(). When performing an operation,
	// a FuzzOperationSpec is selected from this list with probably equal to its
	// 'Prob' field; the 'Prob' fields of all FuzzOperationSpecs here must sum to
	// 1.
	FuzzOperationSpecs []*FuzzOperationSpec `yaml:"fuzzOperations,omitempty"`
}

func Operations(env *Env, repo, commit string, spec *OperationsSpec) error {
	for i := 0; i < spec.Count; i++ {
		if err := FuzzOperation(env, repo, commit, spec.FuzzOperationSpecs); err != nil {
			return err
		}
	}
	return nil
}

// OperationSpec specifies a single intra-commit operation that the fuzzer might
// perform. It's basically an instruction for Operation(), as it executes
// randomly-chosen intra-commit operations.
// TODO(brycemcanally): Add different types of operations.
type OperationSpec struct {
	// PutFileSpec, if set, specifies a PutFile operation. Exactly one of
	// 'PutFileSpec' and 'DeleteFileSpec' should be set.
	PutFileSpec *PutFileSpec `yaml:"putFile,omitempty"`

	// DeleteFileSpec, if set, specifies a DeleteFile operation for Operations().
	// Exactly one of 'PutFileSpec' and 'DeleteFileSpec' should be set.
	DeleteFileSpec *DeleteFileSpec `yaml:"deleteFile,omitempty"`
}

// Operation performs a single intra-commit operation, specified by 'spec'.
// The commit inside of which this operation is performed must be passed in
// 'commit', and 'env' specifies the fuzz-testing environment (e.g. the target
// cluster, the file sources, etc).
func Operation(env *Env, repo, commit string, spec *OperationSpec) error {
	if spec.PutFileSpec != nil {
		return PutFile(env, repo, commit, spec.PutFileSpec)
	}
	return DeleteFile(env, repo, commit, spec.DeleteFileSpec)
}

// PutFileSpec specifies a single PutFile operation, performed inside of a
// fuzzer-generated commit.
type PutFileSpec struct {
	// FilesSpec specifies the files that may be added within this PutFile
	// operation.
	FilesSpec *FilesSpec `yaml:"files,omitempty"`
}

func PutFile(env *Env, repo, commit string, spec *PutFileSpec) error {
	c := env.Client()
	files, err := Files(env, spec.FilesSpec)
	if err != nil {
		return err
	}
	return c.WithModifyFileClient(context.Background(), repo, commit, func(mf client.ModifyFile) error {
		for _, file := range files {
			if err := mf.PutFile(file.Path(), file.Reader()); err != nil {
				return err
			}
		}
		return nil
	})
}

type DeleteFileSpec struct {
	Count         int     `yaml:"count,omitempty"`
	DirectoryProb float64 `yaml:"directoryProb,omitempty"`
}

func DeleteFile(env *Env, repo, commit string, spec *DeleteFileSpec) error {
	c := env.Client()
	return c.WithModifyFileClient(context.Background(), repo, commit, func(mf client.ModifyFile) error {
		for i := 0; i < spec.Count; i++ {
			p, err := nextDeletePath(env, spec)
			if err != nil {
				return err
			}
			if err := mf.DeleteFile(p); err != nil {
				return err
			}
		}
		return nil
	})
}

func nextDeletePath(env *Env, spec *DeleteFileSpec) (string, error) {
	validator := env.Validator()
	p, err := validator.RandomFile()
	if err != nil {
		return "", err
	}
	for shouldExecute(spec.DirectoryProb) {
		p, _ = path.Split(p)
		if p == "" {
			break
		}
	}
	return p, nil
}
