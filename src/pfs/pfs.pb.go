// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pfs/pfs.proto

package pfs

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	auth "github.com/pachyderm/pachyderm/v2/src/auth"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// These are the different places where a commit may be originated from
type OriginKind int32

const (
	OriginKind_USER OriginKind = 0
	OriginKind_AUTO OriginKind = 1
	OriginKind_FSCK OriginKind = 2
)

var OriginKind_name = map[int32]string{
	0: "USER",
	1: "AUTO",
	2: "FSCK",
}

var OriginKind_value = map[string]int32{
	"USER": 0,
	"AUTO": 1,
	"FSCK": 2,
}

func (x OriginKind) String() string {
	return proto.EnumName(OriginKind_name, int32(x))
}

func (OriginKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{0}
}

type FileType int32

const (
	FileType_RESERVED FileType = 0
	FileType_FILE     FileType = 1
	FileType_DIR      FileType = 2
)

var FileType_name = map[int32]string{
	0: "RESERVED",
	1: "FILE",
	2: "DIR",
}

var FileType_value = map[string]int32{
	"RESERVED": 0,
	"FILE":     1,
	"DIR":      2,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}

func (FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{1}
}

// CommitState describes the states a commit can be in.
// The states are increasingly specific, i.e. a commit that is FINISHED also counts as STARTED.
type CommitState int32

const (
	CommitState_STARTED  CommitState = 0
	CommitState_READY    CommitState = 1
	CommitState_FINISHED CommitState = 2
)

var CommitState_name = map[int32]string{
	0: "STARTED",
	1: "READY",
	2: "FINISHED",
}

var CommitState_value = map[string]int32{
	"STARTED":  0,
	"READY":    1,
	"FINISHED": 2,
}

func (x CommitState) String() string {
	return proto.EnumName(CommitState_name, int32(x))
}

func (CommitState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{2}
}

type Delimiter int32

const (
	Delimiter_NONE Delimiter = 0
	Delimiter_JSON Delimiter = 1
	Delimiter_LINE Delimiter = 2
	Delimiter_SQL  Delimiter = 3
	Delimiter_CSV  Delimiter = 4
)

var Delimiter_name = map[int32]string{
	0: "NONE",
	1: "JSON",
	2: "LINE",
	3: "SQL",
	4: "CSV",
}

var Delimiter_value = map[string]int32{
	"NONE": 0,
	"JSON": 1,
	"LINE": 2,
	"SQL":  3,
	"CSV":  4,
}

func (x Delimiter) String() string {
	return proto.EnumName(Delimiter_name, int32(x))
}

func (Delimiter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{3}
}

type Repo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Repo) Reset()         { *m = Repo{} }
func (m *Repo) String() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()    {}
func (*Repo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{0}
}
func (m *Repo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repo.Merge(m, src)
}
func (m *Repo) XXX_Size() int {
	return m.Size()
}
func (m *Repo) XXX_DiscardUnknown() {
	xxx_messageInfo_Repo.DiscardUnknown(m)
}

var xxx_messageInfo_Repo proto.InternalMessageInfo

func (m *Repo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Branch struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Branch) Reset()         { *m = Branch{} }
func (m *Branch) String() string { return proto.CompactTextString(m) }
func (*Branch) ProtoMessage()    {}
func (*Branch) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{1}
}
func (m *Branch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Branch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Branch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Branch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Branch.Merge(m, src)
}
func (m *Branch) XXX_Size() int {
	return m.Size()
}
func (m *Branch) XXX_DiscardUnknown() {
	xxx_messageInfo_Branch.DiscardUnknown(m)
}

var xxx_messageInfo_Branch proto.InternalMessageInfo

func (m *Branch) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Branch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type File struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{2}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// RepoInfo is the main data structure representing a Repo in etcd
type RepoInfo struct {
	Repo        *Repo            `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Created     *types.Timestamp `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	SizeBytes   uint64           `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Description string           `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	Branches    []*Branch        `protobuf:"bytes,7,rep,name=branches,proto3" json:"branches,omitempty"`
	// Set by ListRepo and InspectRepo if Pachyderm's auth system is active, but
	// not stored in etcd. To set a user's auth scope for a repo, use the
	// Pachyderm Auth API (in src/client/auth/auth.proto)
	AuthInfo             *RepoAuthInfo `protobuf:"bytes,6,opt,name=auth_info,json=authInfo,proto3" json:"auth_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RepoInfo) Reset()         { *m = RepoInfo{} }
func (m *RepoInfo) String() string { return proto.CompactTextString(m) }
func (*RepoInfo) ProtoMessage()    {}
func (*RepoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{3}
}
func (m *RepoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoInfo.Merge(m, src)
}
func (m *RepoInfo) XXX_Size() int {
	return m.Size()
}
func (m *RepoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RepoInfo proto.InternalMessageInfo

func (m *RepoInfo) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *RepoInfo) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *RepoInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *RepoInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RepoInfo) GetBranches() []*Branch {
	if m != nil {
		return m.Branches
	}
	return nil
}

func (m *RepoInfo) GetAuthInfo() *RepoAuthInfo {
	if m != nil {
		return m.AuthInfo
	}
	return nil
}

// RepoAuthInfo includes the caller's access scope for a repo, and is returned
// by ListRepo and InspectRepo but not persisted in etcd. It's used by the
// Pachyderm dashboard to render repo access appropriately. To set a user's auth
// scope for a repo, use the Pachyderm Auth API (in src/client/auth/auth.proto)
type RepoAuthInfo struct {
	// The callers access level to the relevant repo (e.g. may be OWNER even if
	// the user isn't an OWNER of the repo, if they're an admin for the cluster)
	Permissions          []auth.Permission `protobuf:"varint,1,rep,packed,name=permissions,proto3,enum=auth.Permission" json:"permissions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RepoAuthInfo) Reset()         { *m = RepoAuthInfo{} }
func (m *RepoAuthInfo) String() string { return proto.CompactTextString(m) }
func (*RepoAuthInfo) ProtoMessage()    {}
func (*RepoAuthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{4}
}
func (m *RepoAuthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoAuthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoAuthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoAuthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoAuthInfo.Merge(m, src)
}
func (m *RepoAuthInfo) XXX_Size() int {
	return m.Size()
}
func (m *RepoAuthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoAuthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RepoAuthInfo proto.InternalMessageInfo

func (m *RepoAuthInfo) GetPermissions() []auth.Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

type BranchInfo struct {
	Branch           *Branch   `protobuf:"bytes,4,opt,name=branch,proto3" json:"branch,omitempty"`
	Head             *Commit   `protobuf:"bytes,2,opt,name=head,proto3" json:"head,omitempty"`
	Provenance       []*Branch `protobuf:"bytes,3,rep,name=provenance,proto3" json:"provenance,omitempty"`
	Subvenance       []*Branch `protobuf:"bytes,5,rep,name=subvenance,proto3" json:"subvenance,omitempty"`
	DirectProvenance []*Branch `protobuf:"bytes,6,rep,name=direct_provenance,json=directProvenance,proto3" json:"direct_provenance,omitempty"`
	Trigger          *Trigger  `protobuf:"bytes,7,opt,name=trigger,proto3" json:"trigger,omitempty"`
	// Deprecated field left for backward compatibility.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BranchInfo) Reset()         { *m = BranchInfo{} }
func (m *BranchInfo) String() string { return proto.CompactTextString(m) }
func (*BranchInfo) ProtoMessage()    {}
func (*BranchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{5}
}
func (m *BranchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BranchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BranchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BranchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BranchInfo.Merge(m, src)
}
func (m *BranchInfo) XXX_Size() int {
	return m.Size()
}
func (m *BranchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BranchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BranchInfo proto.InternalMessageInfo

func (m *BranchInfo) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *BranchInfo) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *BranchInfo) GetProvenance() []*Branch {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BranchInfo) GetSubvenance() []*Branch {
	if m != nil {
		return m.Subvenance
	}
	return nil
}

func (m *BranchInfo) GetDirectProvenance() []*Branch {
	if m != nil {
		return m.DirectProvenance
	}
	return nil
}

func (m *BranchInfo) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *BranchInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type BranchInfos struct {
	BranchInfo           []*BranchInfo `protobuf:"bytes,1,rep,name=branch_info,json=branchInfo,proto3" json:"branch_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BranchInfos) Reset()         { *m = BranchInfos{} }
func (m *BranchInfos) String() string { return proto.CompactTextString(m) }
func (*BranchInfos) ProtoMessage()    {}
func (*BranchInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{6}
}
func (m *BranchInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BranchInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BranchInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BranchInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BranchInfos.Merge(m, src)
}
func (m *BranchInfos) XXX_Size() int {
	return m.Size()
}
func (m *BranchInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_BranchInfos.DiscardUnknown(m)
}

var xxx_messageInfo_BranchInfos proto.InternalMessageInfo

func (m *BranchInfos) GetBranchInfo() []*BranchInfo {
	if m != nil {
		return m.BranchInfo
	}
	return nil
}

// Trigger defines the conditions under which a head is moved, and to which
// branch it is moved.
type Trigger struct {
	// Which branch this trigger refers to
	Branch string `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	// All indicates that all conditions must be satisfied before the trigger
	// happens, otherwise any conditions being satisfied will trigger it.
	All bool `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
	// Triggers if the cron spec has been satisfied since the last trigger and
	// there's been a new commit.
	CronSpec string `protobuf:"bytes,3,opt,name=cron_spec,json=cronSpec,proto3" json:"cron_spec,omitempty"`
	// Triggers if there's been `size` new data added since the last trigger.
	Size_ string `protobuf:"bytes,4,opt,name=size,proto3" json:"size,omitempty"`
	// Triggers if there's been `commits` new commits added since the last trigger.
	Commits              int64    `protobuf:"varint,5,opt,name=commits,proto3" json:"commits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Trigger) Reset()         { *m = Trigger{} }
func (m *Trigger) String() string { return proto.CompactTextString(m) }
func (*Trigger) ProtoMessage()    {}
func (*Trigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{7}
}
func (m *Trigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trigger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trigger.Merge(m, src)
}
func (m *Trigger) XXX_Size() int {
	return m.Size()
}
func (m *Trigger) XXX_DiscardUnknown() {
	xxx_messageInfo_Trigger.DiscardUnknown(m)
}

var xxx_messageInfo_Trigger proto.InternalMessageInfo

func (m *Trigger) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *Trigger) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *Trigger) GetCronSpec() string {
	if m != nil {
		return m.CronSpec
	}
	return ""
}

func (m *Trigger) GetSize_() string {
	if m != nil {
		return m.Size_
	}
	return ""
}

func (m *Trigger) GetCommits() int64 {
	if m != nil {
		return m.Commits
	}
	return 0
}

type CommitOrigin struct {
	Kind                 OriginKind `protobuf:"varint,1,opt,name=kind,proto3,enum=pfs.OriginKind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CommitOrigin) Reset()         { *m = CommitOrigin{} }
func (m *CommitOrigin) String() string { return proto.CompactTextString(m) }
func (*CommitOrigin) ProtoMessage()    {}
func (*CommitOrigin) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{8}
}
func (m *CommitOrigin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitOrigin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitOrigin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitOrigin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitOrigin.Merge(m, src)
}
func (m *CommitOrigin) XXX_Size() int {
	return m.Size()
}
func (m *CommitOrigin) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitOrigin.DiscardUnknown(m)
}

var xxx_messageInfo_CommitOrigin proto.InternalMessageInfo

func (m *CommitOrigin) GetKind() OriginKind {
	if m != nil {
		return m.Kind
	}
	return OriginKind_USER
}

// Commit is a reference to a commit (e.g. the collection of branches and the
// collection of currently-open commits in etcd are collections of Commit
// protos)
type Commit struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	ID                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{9}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Commit) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

// CommitRange represents chain of commits with Lower being an ancestor of
// Upper or, in the case of a range of size 1, the same commit.
type CommitRange struct {
	Lower                *Commit  `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	Upper                *Commit  `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitRange) Reset()         { *m = CommitRange{} }
func (m *CommitRange) String() string { return proto.CompactTextString(m) }
func (*CommitRange) ProtoMessage()    {}
func (*CommitRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{10}
}
func (m *CommitRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitRange.Merge(m, src)
}
func (m *CommitRange) XXX_Size() int {
	return m.Size()
}
func (m *CommitRange) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitRange.DiscardUnknown(m)
}

var xxx_messageInfo_CommitRange proto.InternalMessageInfo

func (m *CommitRange) GetLower() *Commit {
	if m != nil {
		return m.Lower
	}
	return nil
}

func (m *CommitRange) GetUpper() *Commit {
	if m != nil {
		return m.Upper
	}
	return nil
}

// CommitProvenance keeps track of where (i.e. which branch) a certain commit
// originated from. A commit's provenance consists of the commits of
// the commits which are in its causal history.
type CommitProvenance struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Branch               *Branch  `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitProvenance) Reset()         { *m = CommitProvenance{} }
func (m *CommitProvenance) String() string { return proto.CompactTextString(m) }
func (*CommitProvenance) ProtoMessage()    {}
func (*CommitProvenance) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{11}
}
func (m *CommitProvenance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitProvenance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitProvenance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitProvenance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitProvenance.Merge(m, src)
}
func (m *CommitProvenance) XXX_Size() int {
	return m.Size()
}
func (m *CommitProvenance) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitProvenance.DiscardUnknown(m)
}

var xxx_messageInfo_CommitProvenance proto.InternalMessageInfo

func (m *CommitProvenance) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *CommitProvenance) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

// CommitInfo is the main data structure representing a commit in etcd
type CommitInfo struct {
	Commit *Commit       `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Branch *Branch       `protobuf:"bytes,15,opt,name=branch,proto3" json:"branch,omitempty"`
	Origin *CommitOrigin `protobuf:"bytes,17,opt,name=origin,proto3" json:"origin,omitempty"`
	// description is a user-provided script describing this commit
	Description  string           `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	ParentCommit *Commit          `protobuf:"bytes,2,opt,name=parent_commit,json=parentCommit,proto3" json:"parent_commit,omitempty"`
	ChildCommits []*Commit        `protobuf:"bytes,11,rep,name=child_commits,json=childCommits,proto3" json:"child_commits,omitempty"`
	Started      *types.Timestamp `protobuf:"bytes,3,opt,name=started,proto3" json:"started,omitempty"`
	Finished     *types.Timestamp `protobuf:"bytes,4,opt,name=finished,proto3" json:"finished,omitempty"`
	SizeBytes    uint64           `protobuf:"varint,5,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// the commits and their original branches on which this commit is provenant
	Provenance []*CommitProvenance `protobuf:"bytes,16,rep,name=provenance,proto3" json:"provenance,omitempty"`
	// ReadyProvenance is the number of provenant commits which have been
	// finished, if ReadyProvenance == len(Provenance) then the commit is ready
	// to be processed by pps.
	ReadyProvenance         int64          `protobuf:"varint,12,opt,name=ready_provenance,json=readyProvenance,proto3" json:"ready_provenance,omitempty"`
	Subvenance              []*CommitRange `protobuf:"bytes,9,rep,name=subvenance,proto3" json:"subvenance,omitempty"`
	SubvenantCommitsSuccess int64          `protobuf:"varint,18,opt,name=subvenant_commits_success,json=subvenantCommitsSuccess,proto3" json:"subvenant_commits_success,omitempty"`
	SubvenantCommitsFailure int64          `protobuf:"varint,19,opt,name=subvenant_commits_failure,json=subvenantCommitsFailure,proto3" json:"subvenant_commits_failure,omitempty"`
	SubvenantCommitsTotal   int64          `protobuf:"varint,20,opt,name=subvenant_commits_total,json=subvenantCommitsTotal,proto3" json:"subvenant_commits_total,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}       `json:"-"`
	XXX_unrecognized        []byte         `json:"-"`
	XXX_sizecache           int32          `json:"-"`
}

func (m *CommitInfo) Reset()         { *m = CommitInfo{} }
func (m *CommitInfo) String() string { return proto.CompactTextString(m) }
func (*CommitInfo) ProtoMessage()    {}
func (*CommitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{12}
}
func (m *CommitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfo.Merge(m, src)
}
func (m *CommitInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfo proto.InternalMessageInfo

func (m *CommitInfo) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *CommitInfo) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *CommitInfo) GetOrigin() *CommitOrigin {
	if m != nil {
		return m.Origin
	}
	return nil
}

func (m *CommitInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CommitInfo) GetParentCommit() *Commit {
	if m != nil {
		return m.ParentCommit
	}
	return nil
}

func (m *CommitInfo) GetChildCommits() []*Commit {
	if m != nil {
		return m.ChildCommits
	}
	return nil
}

func (m *CommitInfo) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *CommitInfo) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *CommitInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *CommitInfo) GetProvenance() []*CommitProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *CommitInfo) GetReadyProvenance() int64 {
	if m != nil {
		return m.ReadyProvenance
	}
	return 0
}

func (m *CommitInfo) GetSubvenance() []*CommitRange {
	if m != nil {
		return m.Subvenance
	}
	return nil
}

func (m *CommitInfo) GetSubvenantCommitsSuccess() int64 {
	if m != nil {
		return m.SubvenantCommitsSuccess
	}
	return 0
}

func (m *CommitInfo) GetSubvenantCommitsFailure() int64 {
	if m != nil {
		return m.SubvenantCommitsFailure
	}
	return 0
}

func (m *CommitInfo) GetSubvenantCommitsTotal() int64 {
	if m != nil {
		return m.SubvenantCommitsTotal
	}
	return 0
}

type FileInfo struct {
	File                 *File            `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	FileType             FileType         `protobuf:"varint,2,opt,name=file_type,json=fileType,proto3,enum=pfs.FileType" json:"file_type,omitempty"`
	SizeBytes            uint64           `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Committed            *types.Timestamp `protobuf:"bytes,10,opt,name=committed,proto3" json:"committed,omitempty"`
	Hash                 []byte           `protobuf:"bytes,7,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{13}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileInfo) GetFileType() FileType {
	if m != nil {
		return m.FileType
	}
	return FileType_RESERVED
}

func (m *FileInfo) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FileInfo) GetCommitted() *types.Timestamp {
	if m != nil {
		return m.Committed
	}
	return nil
}

func (m *FileInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type CreateRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Update               bool     `protobuf:"varint,4,opt,name=update,proto3" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateRepoRequest) Reset()         { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()    {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{14}
}
func (m *CreateRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRepoRequest.Merge(m, src)
}
func (m *CreateRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRepoRequest proto.InternalMessageInfo

func (m *CreateRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateRepoRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

type InspectRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectRepoRequest) Reset()         { *m = InspectRepoRequest{} }
func (m *InspectRepoRequest) String() string { return proto.CompactTextString(m) }
func (*InspectRepoRequest) ProtoMessage()    {}
func (*InspectRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{15}
}
func (m *InspectRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectRepoRequest.Merge(m, src)
}
func (m *InspectRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectRepoRequest proto.InternalMessageInfo

func (m *InspectRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

type ListRepoRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRepoRequest) Reset()         { *m = ListRepoRequest{} }
func (m *ListRepoRequest) String() string { return proto.CompactTextString(m) }
func (*ListRepoRequest) ProtoMessage()    {}
func (*ListRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{16}
}
func (m *ListRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRepoRequest.Merge(m, src)
}
func (m *ListRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRepoRequest proto.InternalMessageInfo

type ListRepoResponse struct {
	RepoInfo             []*RepoInfo `protobuf:"bytes,1,rep,name=repo_info,json=repoInfo,proto3" json:"repo_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ListRepoResponse) Reset()         { *m = ListRepoResponse{} }
func (m *ListRepoResponse) String() string { return proto.CompactTextString(m) }
func (*ListRepoResponse) ProtoMessage()    {}
func (*ListRepoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{17}
}
func (m *ListRepoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRepoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRepoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRepoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRepoResponse.Merge(m, src)
}
func (m *ListRepoResponse) XXX_Size() int {
	return m.Size()
}
func (m *ListRepoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRepoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRepoResponse proto.InternalMessageInfo

func (m *ListRepoResponse) GetRepoInfo() []*RepoInfo {
	if m != nil {
		return m.RepoInfo
	}
	return nil
}

type DeleteRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	All                  bool     `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRepoRequest) Reset()         { *m = DeleteRepoRequest{} }
func (m *DeleteRepoRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRepoRequest) ProtoMessage()    {}
func (*DeleteRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{18}
}
func (m *DeleteRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRepoRequest.Merge(m, src)
}
func (m *DeleteRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRepoRequest proto.InternalMessageInfo

func (m *DeleteRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *DeleteRepoRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *DeleteRepoRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type StartCommitRequest struct {
	// Parent.ID may be empty in which case the commit that Branch points to will be used as the parent.
	// If branch is empty, or if branch does not exist, the commit will have no parent.
	Parent *Commit `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// description is a user-provided string describing this commit
	Description          string              `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Branch               string              `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance           []*CommitProvenance `protobuf:"bytes,5,rep,name=provenance,proto3" json:"provenance,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *StartCommitRequest) Reset()         { *m = StartCommitRequest{} }
func (m *StartCommitRequest) String() string { return proto.CompactTextString(m) }
func (*StartCommitRequest) ProtoMessage()    {}
func (*StartCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{19}
}
func (m *StartCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartCommitRequest.Merge(m, src)
}
func (m *StartCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartCommitRequest proto.InternalMessageInfo

func (m *StartCommitRequest) GetParent() *Commit {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *StartCommitRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StartCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *StartCommitRequest) GetProvenance() []*CommitProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

type FinishCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// description is a user-provided string describing this commit. Setting this
	// will overwrite the description set in StartCommit
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	SizeBytes   uint64 `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// If set, 'commit' will be closed (its 'finished' field will be set to the
	// current time) but its 'tree' will be left nil.
	Empty                bool     `protobuf:"varint,4,opt,name=empty,proto3" json:"empty,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinishCommitRequest) Reset()         { *m = FinishCommitRequest{} }
func (m *FinishCommitRequest) String() string { return proto.CompactTextString(m) }
func (*FinishCommitRequest) ProtoMessage()    {}
func (*FinishCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{20}
}
func (m *FinishCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCommitRequest.Merge(m, src)
}
func (m *FinishCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCommitRequest proto.InternalMessageInfo

func (m *FinishCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *FinishCommitRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FinishCommitRequest) GetSizeBytes() uint64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FinishCommitRequest) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

type InspectCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// BlockState causes inspect commit to block until the commit is in the desired state.
	BlockState           CommitState `protobuf:"varint,2,opt,name=block_state,json=blockState,proto3,enum=pfs.CommitState" json:"block_state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *InspectCommitRequest) Reset()         { *m = InspectCommitRequest{} }
func (m *InspectCommitRequest) String() string { return proto.CompactTextString(m) }
func (*InspectCommitRequest) ProtoMessage()    {}
func (*InspectCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{21}
}
func (m *InspectCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectCommitRequest.Merge(m, src)
}
func (m *InspectCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectCommitRequest proto.InternalMessageInfo

func (m *InspectCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *InspectCommitRequest) GetBlockState() CommitState {
	if m != nil {
		return m.BlockState
	}
	return CommitState_STARTED
}

type ListCommitRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	From                 *Commit  `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   *Commit  `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Number               uint64   `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	Reverse              bool     `protobuf:"varint,5,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCommitRequest) Reset()         { *m = ListCommitRequest{} }
func (m *ListCommitRequest) String() string { return proto.CompactTextString(m) }
func (*ListCommitRequest) ProtoMessage()    {}
func (*ListCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{22}
}
func (m *ListCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCommitRequest.Merge(m, src)
}
func (m *ListCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCommitRequest proto.InternalMessageInfo

func (m *ListCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListCommitRequest) GetTo() *Commit {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListCommitRequest) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ListCommitRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type CommitInfos struct {
	CommitInfo           []*CommitInfo `protobuf:"bytes,1,rep,name=commit_info,json=commitInfo,proto3" json:"commit_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CommitInfos) Reset()         { *m = CommitInfos{} }
func (m *CommitInfos) String() string { return proto.CompactTextString(m) }
func (*CommitInfos) ProtoMessage()    {}
func (*CommitInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{23}
}
func (m *CommitInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfos.Merge(m, src)
}
func (m *CommitInfos) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfos.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfos proto.InternalMessageInfo

func (m *CommitInfos) GetCommitInfo() []*CommitInfo {
	if m != nil {
		return m.CommitInfo
	}
	return nil
}

type SquashCommitRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SquashCommitRequest) Reset()         { *m = SquashCommitRequest{} }
func (m *SquashCommitRequest) String() string { return proto.CompactTextString(m) }
func (*SquashCommitRequest) ProtoMessage()    {}
func (*SquashCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{24}
}
func (m *SquashCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SquashCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SquashCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SquashCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SquashCommitRequest.Merge(m, src)
}
func (m *SquashCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SquashCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SquashCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SquashCommitRequest proto.InternalMessageInfo

func (m *SquashCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type FlushCommitRequest struct {
	Commits              []*Commit `protobuf:"bytes,1,rep,name=commits,proto3" json:"commits,omitempty"`
	ToRepos              []*Repo   `protobuf:"bytes,2,rep,name=to_repos,json=toRepos,proto3" json:"to_repos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *FlushCommitRequest) Reset()         { *m = FlushCommitRequest{} }
func (m *FlushCommitRequest) String() string { return proto.CompactTextString(m) }
func (*FlushCommitRequest) ProtoMessage()    {}
func (*FlushCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{25}
}
func (m *FlushCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlushCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlushCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlushCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlushCommitRequest.Merge(m, src)
}
func (m *FlushCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *FlushCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FlushCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FlushCommitRequest proto.InternalMessageInfo

func (m *FlushCommitRequest) GetCommits() []*Commit {
	if m != nil {
		return m.Commits
	}
	return nil
}

func (m *FlushCommitRequest) GetToRepos() []*Repo {
	if m != nil {
		return m.ToRepos
	}
	return nil
}

type SubscribeCommitRequest struct {
	Repo   *Repo             `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch string            `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Prov   *CommitProvenance `protobuf:"bytes,5,opt,name=prov,proto3" json:"prov,omitempty"`
	// only commits created since this commit are returned
	From *Commit `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// Don't return commits until they're in (at least) the desired state.
	State                CommitState `protobuf:"varint,4,opt,name=state,proto3,enum=pfs.CommitState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SubscribeCommitRequest) Reset()         { *m = SubscribeCommitRequest{} }
func (m *SubscribeCommitRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeCommitRequest) ProtoMessage()    {}
func (*SubscribeCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{26}
}
func (m *SubscribeCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeCommitRequest.Merge(m, src)
}
func (m *SubscribeCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeCommitRequest proto.InternalMessageInfo

func (m *SubscribeCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *SubscribeCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *SubscribeCommitRequest) GetProv() *CommitProvenance {
	if m != nil {
		return m.Prov
	}
	return nil
}

func (m *SubscribeCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *SubscribeCommitRequest) GetState() CommitState {
	if m != nil {
		return m.State
	}
	return CommitState_STARTED
}

type ClearCommitRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearCommitRequest) Reset()         { *m = ClearCommitRequest{} }
func (m *ClearCommitRequest) String() string { return proto.CompactTextString(m) }
func (*ClearCommitRequest) ProtoMessage()    {}
func (*ClearCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{27}
}
func (m *ClearCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearCommitRequest.Merge(m, src)
}
func (m *ClearCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearCommitRequest proto.InternalMessageInfo

func (m *ClearCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type CreateBranchRequest struct {
	Head *Commit `protobuf:"bytes,1,opt,name=head,proto3" json:"head,omitempty"`
	// s_branch matches the field number and type of SetBranchRequest.Branch in
	// Pachyderm 1.6--so that operations (generated by pachyderm 1.6's
	// Admin.Export) can be deserialized by pachyderm 1.7 correctly
	SBranch              string    `protobuf:"bytes,2,opt,name=s_branch,json=sBranch,proto3" json:"s_branch,omitempty"`
	Branch               *Branch   `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance           []*Branch `protobuf:"bytes,4,rep,name=provenance,proto3" json:"provenance,omitempty"`
	Trigger              *Trigger  `protobuf:"bytes,5,opt,name=trigger,proto3" json:"trigger,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateBranchRequest) Reset()         { *m = CreateBranchRequest{} }
func (m *CreateBranchRequest) String() string { return proto.CompactTextString(m) }
func (*CreateBranchRequest) ProtoMessage()    {}
func (*CreateBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{28}
}
func (m *CreateBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBranchRequest.Merge(m, src)
}
func (m *CreateBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBranchRequest proto.InternalMessageInfo

func (m *CreateBranchRequest) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *CreateBranchRequest) GetSBranch() string {
	if m != nil {
		return m.SBranch
	}
	return ""
}

func (m *CreateBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *CreateBranchRequest) GetProvenance() []*Branch {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *CreateBranchRequest) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

type InspectBranchRequest struct {
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectBranchRequest) Reset()         { *m = InspectBranchRequest{} }
func (m *InspectBranchRequest) String() string { return proto.CompactTextString(m) }
func (*InspectBranchRequest) ProtoMessage()    {}
func (*InspectBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{29}
}
func (m *InspectBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectBranchRequest.Merge(m, src)
}
func (m *InspectBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectBranchRequest proto.InternalMessageInfo

func (m *InspectBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

type ListBranchRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Reverse              bool     `protobuf:"varint,2,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBranchRequest) Reset()         { *m = ListBranchRequest{} }
func (m *ListBranchRequest) String() string { return proto.CompactTextString(m) }
func (*ListBranchRequest) ProtoMessage()    {}
func (*ListBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{30}
}
func (m *ListBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBranchRequest.Merge(m, src)
}
func (m *ListBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBranchRequest proto.InternalMessageInfo

func (m *ListBranchRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListBranchRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type DeleteBranchRequest struct {
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBranchRequest) Reset()         { *m = DeleteBranchRequest{} }
func (m *DeleteBranchRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteBranchRequest) ProtoMessage()    {}
func (*DeleteBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{31}
}
func (m *DeleteBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBranchRequest.Merge(m, src)
}
func (m *DeleteBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBranchRequest proto.InternalMessageInfo

func (m *DeleteBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *DeleteBranchRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type AppendFile struct {
	Overwrite bool   `protobuf:"varint,1,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	Tag       string `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	// Types that are valid to be assigned to Source:
	//	*AppendFile_RawFileSource
	//	*AppendFile_TarFileSource
	//	*AppendFile_UrlFileSource
	Source               isAppendFile_Source `protobuf_oneof:"source"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AppendFile) Reset()         { *m = AppendFile{} }
func (m *AppendFile) String() string { return proto.CompactTextString(m) }
func (*AppendFile) ProtoMessage()    {}
func (*AppendFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{32}
}
func (m *AppendFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendFile.Merge(m, src)
}
func (m *AppendFile) XXX_Size() int {
	return m.Size()
}
func (m *AppendFile) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendFile.DiscardUnknown(m)
}

var xxx_messageInfo_AppendFile proto.InternalMessageInfo

type isAppendFile_Source interface {
	isAppendFile_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AppendFile_RawFileSource struct {
	RawFileSource *RawFileSource `protobuf:"bytes,3,opt,name=raw_file_source,json=rawFileSource,proto3,oneof" json:"raw_file_source,omitempty"`
}
type AppendFile_TarFileSource struct {
	TarFileSource *TarFileSource `protobuf:"bytes,4,opt,name=tar_file_source,json=tarFileSource,proto3,oneof" json:"tar_file_source,omitempty"`
}
type AppendFile_UrlFileSource struct {
	UrlFileSource *URLFileSource `protobuf:"bytes,5,opt,name=url_file_source,json=urlFileSource,proto3,oneof" json:"url_file_source,omitempty"`
}

func (*AppendFile_RawFileSource) isAppendFile_Source() {}
func (*AppendFile_TarFileSource) isAppendFile_Source() {}
func (*AppendFile_UrlFileSource) isAppendFile_Source() {}

func (m *AppendFile) GetSource() isAppendFile_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AppendFile) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

func (m *AppendFile) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *AppendFile) GetRawFileSource() *RawFileSource {
	if x, ok := m.GetSource().(*AppendFile_RawFileSource); ok {
		return x.RawFileSource
	}
	return nil
}

func (m *AppendFile) GetTarFileSource() *TarFileSource {
	if x, ok := m.GetSource().(*AppendFile_TarFileSource); ok {
		return x.TarFileSource
	}
	return nil
}

func (m *AppendFile) GetUrlFileSource() *URLFileSource {
	if x, ok := m.GetSource().(*AppendFile_UrlFileSource); ok {
		return x.UrlFileSource
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AppendFile) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AppendFile_RawFileSource)(nil),
		(*AppendFile_TarFileSource)(nil),
		(*AppendFile_UrlFileSource)(nil),
	}
}

type RawFileSource struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	EOF                  bool     `protobuf:"varint,3,opt,name=EOF,proto3" json:"EOF,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawFileSource) Reset()         { *m = RawFileSource{} }
func (m *RawFileSource) String() string { return proto.CompactTextString(m) }
func (*RawFileSource) ProtoMessage()    {}
func (*RawFileSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{33}
}
func (m *RawFileSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawFileSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawFileSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawFileSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawFileSource.Merge(m, src)
}
func (m *RawFileSource) XXX_Size() int {
	return m.Size()
}
func (m *RawFileSource) XXX_DiscardUnknown() {
	xxx_messageInfo_RawFileSource.DiscardUnknown(m)
}

var xxx_messageInfo_RawFileSource proto.InternalMessageInfo

func (m *RawFileSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *RawFileSource) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *RawFileSource) GetEOF() bool {
	if m != nil {
		return m.EOF
	}
	return false
}

type TarFileSource struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TarFileSource) Reset()         { *m = TarFileSource{} }
func (m *TarFileSource) String() string { return proto.CompactTextString(m) }
func (*TarFileSource) ProtoMessage()    {}
func (*TarFileSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{34}
}
func (m *TarFileSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TarFileSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TarFileSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TarFileSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TarFileSource.Merge(m, src)
}
func (m *TarFileSource) XXX_Size() int {
	return m.Size()
}
func (m *TarFileSource) XXX_DiscardUnknown() {
	xxx_messageInfo_TarFileSource.DiscardUnknown(m)
}

var xxx_messageInfo_TarFileSource proto.InternalMessageInfo

func (m *TarFileSource) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type URLFileSource struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	URL                  string   `protobuf:"bytes,2,opt,name=URL,proto3" json:"URL,omitempty"`
	Recursive            bool     `protobuf:"varint,3,opt,name=recursive,proto3" json:"recursive,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *URLFileSource) Reset()         { *m = URLFileSource{} }
func (m *URLFileSource) String() string { return proto.CompactTextString(m) }
func (*URLFileSource) ProtoMessage()    {}
func (*URLFileSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{35}
}
func (m *URLFileSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *URLFileSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_URLFileSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *URLFileSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_URLFileSource.Merge(m, src)
}
func (m *URLFileSource) XXX_Size() int {
	return m.Size()
}
func (m *URLFileSource) XXX_DiscardUnknown() {
	xxx_messageInfo_URLFileSource.DiscardUnknown(m)
}

var xxx_messageInfo_URLFileSource proto.InternalMessageInfo

func (m *URLFileSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *URLFileSource) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *URLFileSource) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

type DeleteFile struct {
	File                 string   `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Tag                  string   `protobuf:"bytes,2,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteFile) Reset()         { *m = DeleteFile{} }
func (m *DeleteFile) String() string { return proto.CompactTextString(m) }
func (*DeleteFile) ProtoMessage()    {}
func (*DeleteFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{36}
}
func (m *DeleteFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFile.Merge(m, src)
}
func (m *DeleteFile) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFile) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFile.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFile proto.InternalMessageInfo

func (m *DeleteFile) GetFile() string {
	if m != nil {
		return m.File
	}
	return ""
}

func (m *DeleteFile) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

type ModifyFileRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// Types that are valid to be assigned to Modification:
	//	*ModifyFileRequest_AppendFile
	//	*ModifyFileRequest_DeleteFile
	Modification         isModifyFileRequest_Modification `protobuf_oneof:"modification"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *ModifyFileRequest) Reset()         { *m = ModifyFileRequest{} }
func (m *ModifyFileRequest) String() string { return proto.CompactTextString(m) }
func (*ModifyFileRequest) ProtoMessage()    {}
func (*ModifyFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{37}
}
func (m *ModifyFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyFileRequest.Merge(m, src)
}
func (m *ModifyFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyFileRequest proto.InternalMessageInfo

type isModifyFileRequest_Modification interface {
	isModifyFileRequest_Modification()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModifyFileRequest_AppendFile struct {
	AppendFile *AppendFile `protobuf:"bytes,2,opt,name=append_file,json=appendFile,proto3,oneof" json:"append_file,omitempty"`
}
type ModifyFileRequest_DeleteFile struct {
	DeleteFile *DeleteFile `protobuf:"bytes,3,opt,name=delete_file,json=deleteFile,proto3,oneof" json:"delete_file,omitempty"`
}

func (*ModifyFileRequest_AppendFile) isModifyFileRequest_Modification() {}
func (*ModifyFileRequest_DeleteFile) isModifyFileRequest_Modification() {}

func (m *ModifyFileRequest) GetModification() isModifyFileRequest_Modification {
	if m != nil {
		return m.Modification
	}
	return nil
}

func (m *ModifyFileRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *ModifyFileRequest) GetAppendFile() *AppendFile {
	if x, ok := m.GetModification().(*ModifyFileRequest_AppendFile); ok {
		return x.AppendFile
	}
	return nil
}

func (m *ModifyFileRequest) GetDeleteFile() *DeleteFile {
	if x, ok := m.GetModification().(*ModifyFileRequest_DeleteFile); ok {
		return x.DeleteFile
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModifyFileRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModifyFileRequest_AppendFile)(nil),
		(*ModifyFileRequest_DeleteFile)(nil),
	}
}

type CopyFileRequest struct {
	Src                  *File    `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Dst                  *File    `protobuf:"bytes,2,opt,name=dst,proto3" json:"dst,omitempty"`
	Overwrite            bool     `protobuf:"varint,3,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	Tag                  string   `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CopyFileRequest) Reset()         { *m = CopyFileRequest{} }
func (m *CopyFileRequest) String() string { return proto.CompactTextString(m) }
func (*CopyFileRequest) ProtoMessage()    {}
func (*CopyFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{38}
}
func (m *CopyFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyFileRequest.Merge(m, src)
}
func (m *CopyFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *CopyFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CopyFileRequest proto.InternalMessageInfo

func (m *CopyFileRequest) GetSrc() *File {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *CopyFileRequest) GetDst() *File {
	if m != nil {
		return m.Dst
	}
	return nil
}

func (m *CopyFileRequest) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

func (m *CopyFileRequest) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

type GetFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	URL                  string   `protobuf:"bytes,2,opt,name=URL,proto3" json:"URL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFileRequest) Reset()         { *m = GetFileRequest{} }
func (m *GetFileRequest) String() string { return proto.CompactTextString(m) }
func (*GetFileRequest) ProtoMessage()    {}
func (*GetFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{39}
}
func (m *GetFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileRequest.Merge(m, src)
}
func (m *GetFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileRequest proto.InternalMessageInfo

func (m *GetFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetFileRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type InspectFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectFileRequest) Reset()         { *m = InspectFileRequest{} }
func (m *InspectFileRequest) String() string { return proto.CompactTextString(m) }
func (*InspectFileRequest) ProtoMessage()    {}
func (*InspectFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{40}
}
func (m *InspectFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectFileRequest.Merge(m, src)
}
func (m *InspectFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectFileRequest proto.InternalMessageInfo

func (m *InspectFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type ListFileRequest struct {
	// File is the parent directory of the files we want to list. This sets the
	// repo, the commit/branch, and path prefix of files we're interested in
	// If the "path" field is omitted, a list of files at the top level of the repo
	// is returned
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	Full                 bool     `protobuf:"varint,2,opt,name=full,proto3" json:"full,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListFileRequest) Reset()         { *m = ListFileRequest{} }
func (m *ListFileRequest) String() string { return proto.CompactTextString(m) }
func (*ListFileRequest) ProtoMessage()    {}
func (*ListFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{41}
}
func (m *ListFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListFileRequest.Merge(m, src)
}
func (m *ListFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListFileRequest proto.InternalMessageInfo

func (m *ListFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *ListFileRequest) GetFull() bool {
	if m != nil {
		return m.Full
	}
	return false
}

type WalkFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalkFileRequest) Reset()         { *m = WalkFileRequest{} }
func (m *WalkFileRequest) String() string { return proto.CompactTextString(m) }
func (*WalkFileRequest) ProtoMessage()    {}
func (*WalkFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{42}
}
func (m *WalkFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalkFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalkFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalkFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalkFileRequest.Merge(m, src)
}
func (m *WalkFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *WalkFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WalkFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WalkFileRequest proto.InternalMessageInfo

func (m *WalkFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type GlobFileRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Pattern              string   `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GlobFileRequest) Reset()         { *m = GlobFileRequest{} }
func (m *GlobFileRequest) String() string { return proto.CompactTextString(m) }
func (*GlobFileRequest) ProtoMessage()    {}
func (*GlobFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{43}
}
func (m *GlobFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobFileRequest.Merge(m, src)
}
func (m *GlobFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *GlobFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GlobFileRequest proto.InternalMessageInfo

func (m *GlobFileRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *GlobFileRequest) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

type DiffFileRequest struct {
	NewFile *File `protobuf:"bytes,1,opt,name=new_file,json=newFile,proto3" json:"new_file,omitempty"`
	// OldFile may be left nil in which case the same path in the parent of
	// NewFile's commit will be used.
	OldFile              *File    `protobuf:"bytes,2,opt,name=old_file,json=oldFile,proto3" json:"old_file,omitempty"`
	Shallow              bool     `protobuf:"varint,3,opt,name=shallow,proto3" json:"shallow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiffFileRequest) Reset()         { *m = DiffFileRequest{} }
func (m *DiffFileRequest) String() string { return proto.CompactTextString(m) }
func (*DiffFileRequest) ProtoMessage()    {}
func (*DiffFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{44}
}
func (m *DiffFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiffFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiffFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiffFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiffFileRequest.Merge(m, src)
}
func (m *DiffFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiffFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiffFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiffFileRequest proto.InternalMessageInfo

func (m *DiffFileRequest) GetNewFile() *File {
	if m != nil {
		return m.NewFile
	}
	return nil
}

func (m *DiffFileRequest) GetOldFile() *File {
	if m != nil {
		return m.OldFile
	}
	return nil
}

func (m *DiffFileRequest) GetShallow() bool {
	if m != nil {
		return m.Shallow
	}
	return false
}

type DiffFileResponse struct {
	NewFile              *FileInfo `protobuf:"bytes,1,opt,name=new_file,json=newFile,proto3" json:"new_file,omitempty"`
	OldFile              *FileInfo `protobuf:"bytes,2,opt,name=old_file,json=oldFile,proto3" json:"old_file,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DiffFileResponse) Reset()         { *m = DiffFileResponse{} }
func (m *DiffFileResponse) String() string { return proto.CompactTextString(m) }
func (*DiffFileResponse) ProtoMessage()    {}
func (*DiffFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{45}
}
func (m *DiffFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiffFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiffFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiffFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiffFileResponse.Merge(m, src)
}
func (m *DiffFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiffFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiffFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiffFileResponse proto.InternalMessageInfo

func (m *DiffFileResponse) GetNewFile() *FileInfo {
	if m != nil {
		return m.NewFile
	}
	return nil
}

func (m *DiffFileResponse) GetOldFile() *FileInfo {
	if m != nil {
		return m.OldFile
	}
	return nil
}

type FsckRequest struct {
	Fix                  bool     `protobuf:"varint,1,opt,name=fix,proto3" json:"fix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsckRequest) Reset()         { *m = FsckRequest{} }
func (m *FsckRequest) String() string { return proto.CompactTextString(m) }
func (*FsckRequest) ProtoMessage()    {}
func (*FsckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{46}
}
func (m *FsckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FsckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FsckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FsckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsckRequest.Merge(m, src)
}
func (m *FsckRequest) XXX_Size() int {
	return m.Size()
}
func (m *FsckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FsckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FsckRequest proto.InternalMessageInfo

func (m *FsckRequest) GetFix() bool {
	if m != nil {
		return m.Fix
	}
	return false
}

type FsckResponse struct {
	Fix                  string   `protobuf:"bytes,1,opt,name=fix,proto3" json:"fix,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsckResponse) Reset()         { *m = FsckResponse{} }
func (m *FsckResponse) String() string { return proto.CompactTextString(m) }
func (*FsckResponse) ProtoMessage()    {}
func (*FsckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{47}
}
func (m *FsckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FsckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FsckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FsckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsckResponse.Merge(m, src)
}
func (m *FsckResponse) XXX_Size() int {
	return m.Size()
}
func (m *FsckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FsckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FsckResponse proto.InternalMessageInfo

func (m *FsckResponse) GetFix() string {
	if m != nil {
		return m.Fix
	}
	return ""
}

func (m *FsckResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CreateFilesetResponse struct {
	FilesetId            string   `protobuf:"bytes,1,opt,name=fileset_id,json=filesetId,proto3" json:"fileset_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFilesetResponse) Reset()         { *m = CreateFilesetResponse{} }
func (m *CreateFilesetResponse) String() string { return proto.CompactTextString(m) }
func (*CreateFilesetResponse) ProtoMessage()    {}
func (*CreateFilesetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{48}
}
func (m *CreateFilesetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFilesetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFilesetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateFilesetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFilesetResponse.Merge(m, src)
}
func (m *CreateFilesetResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateFilesetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFilesetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFilesetResponse proto.InternalMessageInfo

func (m *CreateFilesetResponse) GetFilesetId() string {
	if m != nil {
		return m.FilesetId
	}
	return ""
}

type RenewFilesetRequest struct {
	FilesetId            string   `protobuf:"bytes,1,opt,name=fileset_id,json=filesetId,proto3" json:"fileset_id,omitempty"`
	TtlSeconds           int64    `protobuf:"varint,2,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenewFilesetRequest) Reset()         { *m = RenewFilesetRequest{} }
func (m *RenewFilesetRequest) String() string { return proto.CompactTextString(m) }
func (*RenewFilesetRequest) ProtoMessage()    {}
func (*RenewFilesetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{49}
}
func (m *RenewFilesetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewFilesetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewFilesetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewFilesetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewFilesetRequest.Merge(m, src)
}
func (m *RenewFilesetRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenewFilesetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewFilesetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenewFilesetRequest proto.InternalMessageInfo

func (m *RenewFilesetRequest) GetFilesetId() string {
	if m != nil {
		return m.FilesetId
	}
	return ""
}

func (m *RenewFilesetRequest) GetTtlSeconds() int64 {
	if m != nil {
		return m.TtlSeconds
	}
	return 0
}

type AddFilesetRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	FilesetId            string   `protobuf:"bytes,2,opt,name=fileset_id,json=filesetId,proto3" json:"fileset_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFilesetRequest) Reset()         { *m = AddFilesetRequest{} }
func (m *AddFilesetRequest) String() string { return proto.CompactTextString(m) }
func (*AddFilesetRequest) ProtoMessage()    {}
func (*AddFilesetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{50}
}
func (m *AddFilesetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFilesetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFilesetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFilesetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFilesetRequest.Merge(m, src)
}
func (m *AddFilesetRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddFilesetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFilesetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddFilesetRequest proto.InternalMessageInfo

func (m *AddFilesetRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *AddFilesetRequest) GetFilesetId() string {
	if m != nil {
		return m.FilesetId
	}
	return ""
}

type GetFilesetRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFilesetRequest) Reset()         { *m = GetFilesetRequest{} }
func (m *GetFilesetRequest) String() string { return proto.CompactTextString(m) }
func (*GetFilesetRequest) ProtoMessage()    {}
func (*GetFilesetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{51}
}
func (m *GetFilesetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFilesetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFilesetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFilesetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFilesetRequest.Merge(m, src)
}
func (m *GetFilesetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFilesetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFilesetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFilesetRequest proto.InternalMessageInfo

func (m *GetFilesetRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type ActivateAuthRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthRequest) Reset()         { *m = ActivateAuthRequest{} }
func (m *ActivateAuthRequest) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthRequest) ProtoMessage()    {}
func (*ActivateAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{52}
}
func (m *ActivateAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthRequest.Merge(m, src)
}
func (m *ActivateAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthRequest proto.InternalMessageInfo

type ActivateAuthResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthResponse) Reset()         { *m = ActivateAuthResponse{} }
func (m *ActivateAuthResponse) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthResponse) ProtoMessage()    {}
func (*ActivateAuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{53}
}
func (m *ActivateAuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthResponse.Merge(m, src)
}
func (m *ActivateAuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("pfs.OriginKind", OriginKind_name, OriginKind_value)
	proto.RegisterEnum("pfs.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("pfs.CommitState", CommitState_name, CommitState_value)
	proto.RegisterEnum("pfs.Delimiter", Delimiter_name, Delimiter_value)
	proto.RegisterType((*Repo)(nil), "pfs.Repo")
	proto.RegisterType((*Branch)(nil), "pfs.Branch")
	proto.RegisterType((*File)(nil), "pfs.File")
	proto.RegisterType((*RepoInfo)(nil), "pfs.RepoInfo")
	proto.RegisterType((*RepoAuthInfo)(nil), "pfs.RepoAuthInfo")
	proto.RegisterType((*BranchInfo)(nil), "pfs.BranchInfo")
	proto.RegisterType((*BranchInfos)(nil), "pfs.BranchInfos")
	proto.RegisterType((*Trigger)(nil), "pfs.Trigger")
	proto.RegisterType((*CommitOrigin)(nil), "pfs.CommitOrigin")
	proto.RegisterType((*Commit)(nil), "pfs.Commit")
	proto.RegisterType((*CommitRange)(nil), "pfs.CommitRange")
	proto.RegisterType((*CommitProvenance)(nil), "pfs.CommitProvenance")
	proto.RegisterType((*CommitInfo)(nil), "pfs.CommitInfo")
	proto.RegisterType((*FileInfo)(nil), "pfs.FileInfo")
	proto.RegisterType((*CreateRepoRequest)(nil), "pfs.CreateRepoRequest")
	proto.RegisterType((*InspectRepoRequest)(nil), "pfs.InspectRepoRequest")
	proto.RegisterType((*ListRepoRequest)(nil), "pfs.ListRepoRequest")
	proto.RegisterType((*ListRepoResponse)(nil), "pfs.ListRepoResponse")
	proto.RegisterType((*DeleteRepoRequest)(nil), "pfs.DeleteRepoRequest")
	proto.RegisterType((*StartCommitRequest)(nil), "pfs.StartCommitRequest")
	proto.RegisterType((*FinishCommitRequest)(nil), "pfs.FinishCommitRequest")
	proto.RegisterType((*InspectCommitRequest)(nil), "pfs.InspectCommitRequest")
	proto.RegisterType((*ListCommitRequest)(nil), "pfs.ListCommitRequest")
	proto.RegisterType((*CommitInfos)(nil), "pfs.CommitInfos")
	proto.RegisterType((*SquashCommitRequest)(nil), "pfs.SquashCommitRequest")
	proto.RegisterType((*FlushCommitRequest)(nil), "pfs.FlushCommitRequest")
	proto.RegisterType((*SubscribeCommitRequest)(nil), "pfs.SubscribeCommitRequest")
	proto.RegisterType((*ClearCommitRequest)(nil), "pfs.ClearCommitRequest")
	proto.RegisterType((*CreateBranchRequest)(nil), "pfs.CreateBranchRequest")
	proto.RegisterType((*InspectBranchRequest)(nil), "pfs.InspectBranchRequest")
	proto.RegisterType((*ListBranchRequest)(nil), "pfs.ListBranchRequest")
	proto.RegisterType((*DeleteBranchRequest)(nil), "pfs.DeleteBranchRequest")
	proto.RegisterType((*AppendFile)(nil), "pfs.AppendFile")
	proto.RegisterType((*RawFileSource)(nil), "pfs.RawFileSource")
	proto.RegisterType((*TarFileSource)(nil), "pfs.TarFileSource")
	proto.RegisterType((*URLFileSource)(nil), "pfs.URLFileSource")
	proto.RegisterType((*DeleteFile)(nil), "pfs.DeleteFile")
	proto.RegisterType((*ModifyFileRequest)(nil), "pfs.ModifyFileRequest")
	proto.RegisterType((*CopyFileRequest)(nil), "pfs.CopyFileRequest")
	proto.RegisterType((*GetFileRequest)(nil), "pfs.GetFileRequest")
	proto.RegisterType((*InspectFileRequest)(nil), "pfs.InspectFileRequest")
	proto.RegisterType((*ListFileRequest)(nil), "pfs.ListFileRequest")
	proto.RegisterType((*WalkFileRequest)(nil), "pfs.WalkFileRequest")
	proto.RegisterType((*GlobFileRequest)(nil), "pfs.GlobFileRequest")
	proto.RegisterType((*DiffFileRequest)(nil), "pfs.DiffFileRequest")
	proto.RegisterType((*DiffFileResponse)(nil), "pfs.DiffFileResponse")
	proto.RegisterType((*FsckRequest)(nil), "pfs.FsckRequest")
	proto.RegisterType((*FsckResponse)(nil), "pfs.FsckResponse")
	proto.RegisterType((*CreateFilesetResponse)(nil), "pfs.CreateFilesetResponse")
	proto.RegisterType((*RenewFilesetRequest)(nil), "pfs.RenewFilesetRequest")
	proto.RegisterType((*AddFilesetRequest)(nil), "pfs.AddFilesetRequest")
	proto.RegisterType((*GetFilesetRequest)(nil), "pfs.GetFilesetRequest")
	proto.RegisterType((*ActivateAuthRequest)(nil), "pfs.ActivateAuthRequest")
	proto.RegisterType((*ActivateAuthResponse)(nil), "pfs.ActivateAuthResponse")
}

func init() { proto.RegisterFile("pfs/pfs.proto", fileDescriptor_21a7b2476cbc6216) }

var fileDescriptor_21a7b2476cbc6216 = []byte{
	// 2623 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x38, 0xfd, 0x6e, 0xdb, 0xd6,
	0xf5, 0xa6, 0x44, 0x49, 0xd4, 0x91, 0x1c, 0xd1, 0xd7, 0x8e, 0xa3, 0xc8, 0xbf, 0xc6, 0xf9, 0x5d,
	0x77, 0x9d, 0xeb, 0x02, 0xb6, 0xe7, 0xac, 0x69, 0xda, 0xac, 0x4d, 0xfd, 0x21, 0x37, 0x76, 0xbd,
	0x38, 0xa3, 0xec, 0x14, 0x2b, 0x06, 0x08, 0x14, 0x75, 0x65, 0x11, 0xa1, 0x44, 0x96, 0xa4, 0xec,
	0x79, 0x03, 0x86, 0xbd, 0xc2, 0xb0, 0x37, 0xe8, 0x13, 0xec, 0x19, 0xb6, 0x7f, 0x06, 0xec, 0x9f,
	0x3d, 0xc1, 0x30, 0x04, 0x7b, 0x8f, 0x0d, 0xf7, 0x83, 0xe2, 0x25, 0x29, 0xc9, 0x76, 0xfe, 0xb1,
	0x2f, 0xcf, 0xc7, 0x3d, 0xe7, 0x9e, 0xef, 0x23, 0x98, 0xf7, 0x7a, 0xc1, 0x96, 0xd7, 0x0b, 0x36,
	0x3d, 0xdf, 0x0d, 0x5d, 0x94, 0xf7, 0x7a, 0x41, 0x63, 0xe5, 0xc2, 0x75, 0x2f, 0x1c, 0xb2, 0xc5,
	0x40, 0x9d, 0x51, 0x6f, 0x8b, 0x0c, 0xbc, 0xf0, 0x9a, 0x53, 0x34, 0x56, 0xd3, 0xc8, 0xd0, 0x1e,
	0x90, 0x20, 0x34, 0x07, 0x9e, 0x20, 0x78, 0x94, 0x26, 0xb8, 0xf2, 0x4d, 0xcf, 0x23, 0xbe, 0x10,
	0xd1, 0x58, 0xba, 0x70, 0x2f, 0x5c, 0x76, 0xdc, 0xa2, 0x27, 0x01, 0xad, 0x99, 0xa3, 0xb0, 0xbf,
	0x45, 0xff, 0x70, 0x00, 0x6e, 0x80, 0x6a, 0x10, 0xcf, 0x45, 0x08, 0xd4, 0xa1, 0x39, 0x20, 0x75,
	0xe5, 0xb1, 0xb2, 0x5e, 0x36, 0xd8, 0x19, 0x3f, 0x87, 0xe2, 0x9e, 0x6f, 0x0e, 0xad, 0x3e, 0xfa,
	0x00, 0x54, 0x9f, 0x78, 0x2e, 0xc3, 0x56, 0x76, 0xca, 0x9b, 0xf4, 0x25, 0x94, 0xcd, 0x60, 0xe0,
	0x31, 0x73, 0x4e, 0x62, 0x7e, 0x01, 0xea, 0xa1, 0xed, 0x10, 0xb4, 0x06, 0x45, 0xcb, 0x1d, 0x0c,
	0xec, 0x50, 0x30, 0x57, 0x18, 0xf3, 0x3e, 0x03, 0x19, 0x02, 0x45, 0x2f, 0xf0, 0xcc, 0xb0, 0x1f,
	0x5d, 0x40, 0xcf, 0xf8, 0xbf, 0x0a, 0x68, 0x54, 0xc6, 0xd1, 0xb0, 0xe7, 0xde, 0xa4, 0xc0, 0xcf,
	0xa1, 0x64, 0xf9, 0xc4, 0x0c, 0x49, 0x97, 0x5d, 0x51, 0xd9, 0x69, 0x6c, 0x72, 0xf3, 0x6c, 0x46,
	0xe6, 0xd9, 0x3c, 0x8b, 0xec, 0x67, 0x44, 0xa4, 0xe8, 0x03, 0x80, 0xc0, 0xfe, 0x1d, 0x69, 0x77,
	0xae, 0x43, 0x12, 0xd4, 0xf3, 0x8f, 0x95, 0x75, 0xd5, 0x28, 0x53, 0xc8, 0x1e, 0x05, 0xa0, 0xc7,
	0x50, 0xe9, 0x92, 0xc0, 0xf2, 0x6d, 0x2f, 0xb4, 0xdd, 0x61, 0xbd, 0xc0, 0x74, 0x93, 0x41, 0xe8,
	0xa7, 0xa0, 0x75, 0x98, 0x81, 0x48, 0x50, 0x2f, 0x3d, 0xce, 0x8f, 0x5f, 0xc7, 0xad, 0x66, 0x8c,
	0x91, 0x68, 0x13, 0xca, 0xd4, 0xe6, 0x6d, 0x7b, 0xd8, 0x73, 0xeb, 0x45, 0xa6, 0xe1, 0xc2, 0xf8,
	0x0d, 0xbb, 0xa3, 0xb0, 0x4f, 0x1f, 0x69, 0x68, 0xa6, 0x38, 0x1d, 0xab, 0x9a, 0xaa, 0x17, 0xf0,
	0x1e, 0x54, 0x65, 0x3c, 0xda, 0x81, 0x8a, 0x47, 0xfc, 0x81, 0x1d, 0x04, 0xb6, 0x3b, 0x0c, 0xea,
	0xca, 0xe3, 0xfc, 0xfa, 0xbd, 0x1d, 0x7d, 0x93, 0x79, 0xf3, 0xf5, 0x18, 0x61, 0xc8, 0x44, 0xf8,
	0xc7, 0x1c, 0x00, 0x57, 0x87, 0x5d, 0xb1, 0x06, 0x45, 0xae, 0x54, 0x5d, 0x95, 0xbc, 0x21, 0xf4,
	0x15, 0x28, 0xb4, 0x0a, 0x6a, 0x9f, 0x98, 0x91, 0x29, 0x13, 0x0e, 0x63, 0x08, 0xf4, 0x09, 0x80,
	0xe7, 0xbb, 0x97, 0x64, 0x68, 0x0e, 0x2d, 0x52, 0xcf, 0x67, 0x5f, 0x2e, 0xa1, 0x29, 0x71, 0x30,
	0xea, 0x44, 0xc4, 0x85, 0x09, 0xc4, 0x31, 0x1a, 0x3d, 0x83, 0x85, 0xae, 0xed, 0x13, 0x2b, 0x6c,
	0x4b, 0x02, 0x8a, 0x59, 0x1e, 0x9d, 0x53, 0xbd, 0x8e, 0xc5, 0x7c, 0x04, 0xa5, 0xd0, 0xb7, 0x2f,
	0x2e, 0x88, 0x5f, 0x2f, 0x31, 0xbd, 0xab, 0x8c, 0xfe, 0x8c, 0xc3, 0x8c, 0x08, 0x39, 0x31, 0xd0,
	0x5f, 0x40, 0x25, 0xb6, 0x51, 0x80, 0xb6, 0xa1, 0xc2, 0x2d, 0xc1, 0xfd, 0xa5, 0x30, 0xf1, 0x35,
	0x49, 0x3c, 0xf3, 0x16, 0x74, 0xc6, 0x67, 0xfc, 0x07, 0x28, 0x09, 0x41, 0x68, 0x79, 0x6c, 0x61,
	0x2e, 0x21, 0x32, 0xaa, 0x0e, 0x79, 0xd3, 0x71, 0x98, 0x4d, 0x35, 0x83, 0x1e, 0xd1, 0x0a, 0x94,
	0x2d, 0xdf, 0x1d, 0xb6, 0x03, 0x8f, 0x58, 0x2c, 0xfa, 0xca, 0x86, 0x46, 0x01, 0x2d, 0x8f, 0x58,
	0x54, 0x4d, 0x1a, 0x89, 0xcc, 0x4d, 0x65, 0x83, 0x9d, 0x51, 0x1d, 0x4a, 0x3c, 0x5f, 0x02, 0x16,
	0x8c, 0x79, 0x23, 0xfa, 0xc4, 0x4f, 0xa0, 0xca, 0x1d, 0x74, 0xea, 0xdb, 0x17, 0xf6, 0x10, 0xad,
	0x81, 0xfa, 0xd6, 0x1e, 0x76, 0x99, 0x0a, 0xf7, 0x84, 0xea, 0x1c, 0xf5, 0xad, 0x3d, 0xec, 0x1a,
	0x0c, 0x89, 0x5f, 0x40, 0x91, 0x33, 0xdd, 0x94, 0x5d, 0xcb, 0x90, 0xb3, 0x79, 0x34, 0x94, 0xf7,
	0x8a, 0xef, 0xfe, 0xb5, 0x9a, 0x3b, 0x3a, 0x30, 0x72, 0x76, 0x17, 0xb7, 0xa0, 0x22, 0xc2, 0xc2,
	0x1c, 0x5e, 0x10, 0xf4, 0xff, 0x50, 0x70, 0xdc, 0x2b, 0xe2, 0x4f, 0x4a, 0x74, 0x8e, 0xa1, 0x24,
	0x23, 0x5a, 0xa4, 0x26, 0x85, 0x16, 0xc7, 0xe0, 0xdf, 0x80, 0xce, 0x01, 0x92, 0x6f, 0x6f, 0x55,
	0x43, 0xe2, 0xd0, 0xce, 0x4d, 0x0d, 0x6d, 0xfc, 0x9f, 0x02, 0x00, 0xe7, 0x8b, 0xd2, 0xe1, 0x2e,
	0x17, 0xd7, 0xa6, 0xe7, 0xcc, 0xc7, 0x50, 0x74, 0x99, 0x81, 0xeb, 0x0b, 0x52, 0x7a, 0xcb, 0x4e,
	0x31, 0x04, 0x41, 0xba, 0xae, 0x68, 0xd9, 0xba, 0xb2, 0x0d, 0xf3, 0x9e, 0xe9, 0x93, 0x61, 0xd8,
	0x16, 0xda, 0x4d, 0x30, 0x57, 0x95, 0x53, 0x08, 0x0f, 0x6e, 0xc3, 0xbc, 0xd5, 0xb7, 0x9d, 0x6e,
	0x3b, 0x0a, 0x90, 0x8a, 0x94, 0x33, 0x11, 0x07, 0xa3, 0xe0, 0x1f, 0x01, 0x2d, 0x99, 0x41, 0x68,
	0xfa, 0xb4, 0x64, 0xe6, 0x6f, 0x2e, 0x99, 0x82, 0x14, 0x3d, 0x05, 0xad, 0x67, 0x0f, 0xed, 0xa0,
	0x4f, 0xba, 0xa2, 0x82, 0xcc, 0x62, 0x1b, 0xd3, 0xa6, 0x4a, 0x6d, 0x21, 0x5d, 0x6a, 0x3f, 0x4d,
	0x14, 0x14, 0x9d, 0xe9, 0x7e, 0x5f, 0xd2, 0x3d, 0x8e, 0x85, 0x44, 0x69, 0xf9, 0x18, 0x74, 0x9f,
	0x98, 0xdd, 0x6b, 0xb9, 0x58, 0x54, 0x59, 0x66, 0xd4, 0x18, 0x5c, 0x0a, 0xa1, 0xed, 0x44, 0x15,
	0x2a, 0x33, 0x09, 0xba, 0x6c, 0x1d, 0x1a, 0xc2, 0x89, 0x52, 0xf4, 0x05, 0x3c, 0x8c, 0xbe, 0x22,
	0x3f, 0x04, 0xed, 0x60, 0x64, 0x59, 0x24, 0x08, 0xea, 0x88, 0x49, 0x79, 0x30, 0x26, 0x10, 0x56,
	0x6d, 0x71, 0xf4, 0x64, 0xde, 0x9e, 0x69, 0x3b, 0x23, 0x9f, 0xd4, 0x17, 0x27, 0xf3, 0x1e, 0x72,
	0x34, 0x7a, 0x0a, 0x0f, 0xb2, 0xbc, 0xa1, 0x1b, 0x9a, 0x4e, 0x7d, 0x89, 0x71, 0xde, 0x4f, 0x73,
	0x9e, 0x51, 0xe4, 0xb1, 0xaa, 0x15, 0xf5, 0xd2, 0xb1, 0xaa, 0x81, 0x5e, 0xc1, 0x7f, 0x55, 0x40,
	0xa3, 0xdd, 0x37, 0xea, 0x9d, 0x3d, 0xdb, 0x21, 0x89, 0xec, 0xa6, 0x48, 0x83, 0x81, 0xd1, 0x06,
	0x94, 0xe9, 0xff, 0x76, 0x78, 0xed, 0xf1, 0x0e, 0x7e, 0x6f, 0x67, 0x7e, 0x4c, 0x73, 0x76, 0xed,
	0x11, 0xea, 0x46, 0x7e, 0xba, 0xa9, 0x63, 0x3e, 0x83, 0x32, 0x57, 0x98, 0x46, 0x15, 0xdc, 0x18,
	0x1e, 0x31, 0x31, 0x2d, 0x77, 0x7d, 0x33, 0xe8, 0xb3, 0xd2, 0x5d, 0x35, 0xd8, 0x19, 0xfb, 0xb0,
	0xb0, 0xcf, 0x3a, 0x35, 0x2b, 0x45, 0xe4, 0x87, 0x11, 0x09, 0x6e, 0x2c, 0x55, 0xa9, 0xdc, 0xca,
	0x67, 0x73, 0x6b, 0x19, 0x8a, 0x23, 0xaf, 0x6b, 0x86, 0xbc, 0xb4, 0x6a, 0x86, 0xf8, 0x3a, 0x56,
	0xb5, 0x9c, 0x9e, 0xc7, 0x4f, 0x00, 0x1d, 0x0d, 0x69, 0x41, 0x0e, 0x6f, 0x2f, 0x14, 0x3f, 0x80,
	0xda, 0x89, 0x1d, 0xc8, 0x1c, 0xc7, 0xaa, 0xa6, 0xe8, 0x39, 0xfc, 0x15, 0xe8, 0x31, 0x22, 0xf0,
	0xdc, 0x61, 0xc0, 0xcc, 0x4d, 0x99, 0xe4, 0xd6, 0x32, 0x3f, 0xbe, 0x90, 0x8f, 0x01, 0xbe, 0x38,
	0xe1, 0xef, 0x61, 0xe1, 0x80, 0x38, 0xe4, 0x4e, 0x16, 0x58, 0x82, 0x42, 0xcf, 0xf5, 0x2d, 0x22,
	0x3a, 0x0d, 0xff, 0x88, 0xba, 0x4f, 0x7e, 0xdc, 0x7d, 0xf0, 0x5f, 0x14, 0x40, 0x2d, 0x9a, 0xd5,
	0x22, 0xfe, 0xc5, 0xed, 0x6b, 0x50, 0xe4, 0x85, 0x65, 0x62, 0x45, 0xe4, 0xa8, 0xb4, 0x95, 0xd5,
	0x89, 0x56, 0x16, 0x35, 0x33, 0x9f, 0xe8, 0x82, 0xc9, 0x44, 0x2f, 0xdc, 0x32, 0xd1, 0x85, 0x73,
	0xfe, 0xa4, 0xc0, 0xe2, 0x21, 0xab, 0x28, 0x19, 0x9d, 0x6f, 0xae, 0xe2, 0x29, 0x9d, 0x73, 0x59,
	0x9d, 0x93, 0xc1, 0x5d, 0x4c, 0x07, 0xf7, 0x12, 0x14, 0xd8, 0x80, 0x2e, 0xe2, 0x86, 0x7f, 0xe0,
	0x21, 0x2c, 0x89, 0x80, 0x79, 0x0f, 0x9d, 0x7e, 0x06, 0x95, 0x8e, 0xe3, 0x5a, 0x6f, 0xdb, 0x41,
	0x48, 0x03, 0x92, 0x27, 0x9f, 0x5c, 0x95, 0x5a, 0x14, 0x6e, 0x00, 0x23, 0x62, 0x67, 0xfc, 0xa3,
	0x02, 0x0b, 0x34, 0xa6, 0x92, 0xd2, 0x6e, 0x88, 0x89, 0x55, 0x50, 0x7b, 0xbe, 0x3b, 0x98, 0x38,
	0xd0, 0x51, 0x04, 0x5a, 0x81, 0x5c, 0xe8, 0x8a, 0x3e, 0x90, 0x40, 0xe7, 0x42, 0xda, 0xfe, 0x8b,
	0xc3, 0xd1, 0xa0, 0x43, 0x7c, 0xf6, 0x72, 0xd5, 0x10, 0x5f, 0x74, 0x1c, 0xf1, 0xc9, 0x25, 0xf1,
	0x03, 0xc2, 0x0a, 0xba, 0x66, 0x44, 0x9f, 0x74, 0x9e, 0x8a, 0x9b, 0x2c, 0x9b, 0xa7, 0xf8, 0x83,
	0xb3, 0xf3, 0x54, 0x4c, 0x66, 0x80, 0x35, 0x3e, 0xe3, 0x2f, 0x60, 0xb1, 0xf5, 0xc3, 0xc8, 0x7c,
	0x1f, 0x47, 0x63, 0x13, 0xd0, 0xa1, 0x33, 0x4a, 0xb3, 0xfe, 0x24, 0x9e, 0x9d, 0x94, 0x6c, 0x6b,
	0x8c, 0x70, 0xe8, 0x43, 0xd0, 0x42, 0xb7, 0x4d, 0x8d, 0x16, 0xd4, 0x73, 0x8c, 0x4e, 0x32, 0x66,
	0x29, 0x74, 0xe9, 0xff, 0x00, 0xff, 0x4d, 0x81, 0xe5, 0xd6, 0xa8, 0x43, 0x43, 0xa7, 0x43, 0xee,
	0xe4, 0x89, 0xe5, 0xc4, 0x90, 0x52, 0x96, 0xc6, 0x07, 0x95, 0x86, 0x3b, 0x33, 0xe4, 0xd4, 0x8c,
	0x60, 0x24, 0x63, 0x67, 0xe6, 0xa7, 0x39, 0xf3, 0x23, 0x28, 0xf0, 0x78, 0x52, 0xa7, 0xc4, 0x13,
	0x47, 0xe3, 0xcf, 0x01, 0xed, 0x3b, 0xc4, 0xf4, 0xdf, 0xc3, 0xc6, 0xff, 0x50, 0x60, 0x91, 0xd7,
	0x66, 0x31, 0x06, 0x09, 0xe6, 0x68, 0x73, 0x50, 0xa6, 0x6d, 0x0e, 0x0f, 0x41, 0x0b, 0xda, 0x09,
	0x0b, 0x94, 0x02, 0xb1, 0x63, 0xae, 0x25, 0x4a, 0xc6, 0x94, 0x31, 0x2b, 0xb9, 0x79, 0xa8, 0xb3,
	0x37, 0x0f, 0x69, 0x25, 0x28, 0xcc, 0x58, 0x09, 0xf0, 0xf3, 0x71, 0x0e, 0x27, 0x5f, 0xb3, 0x96,
	0x18, 0xe5, 0xa7, 0x4c, 0x94, 0x27, 0x3c, 0x1f, 0x93, 0x9c, 0x37, 0x44, 0x81, 0x94, 0x39, 0xb9,
	0x64, 0xe6, 0xbc, 0x86, 0x45, 0x5e, 0xf1, 0xef, 0xae, 0xc9, 0xe4, 0xca, 0x8f, 0xff, 0x98, 0x03,
	0xd8, 0xf5, 0x3c, 0x32, 0xec, 0xb2, 0x75, 0xfc, 0xff, 0xa0, 0xec, 0x5e, 0x12, 0xff, 0xca, 0xb7,
	0x43, 0x3e, 0x11, 0x68, 0x46, 0x0c, 0xa0, 0x6d, 0x22, 0x34, 0x2f, 0x84, 0x67, 0xe8, 0x11, 0xfd,
	0x02, 0x6a, 0xbe, 0x79, 0xd5, 0x66, 0x13, 0x42, 0xe0, 0x8e, 0x7c, 0xb6, 0xef, 0x51, 0x15, 0x10,
	0x7f, 0x94, 0x79, 0x45, 0xaf, 0x6d, 0x31, 0xcc, 0xcb, 0x39, 0x63, 0xde, 0x97, 0x01, 0x94, 0x3b,
	0x34, 0xfd, 0x04, 0xb7, 0x2a, 0x71, 0x9f, 0x99, 0x7e, 0x92, 0x3b, 0x94, 0x01, 0x94, 0x7b, 0xe4,
	0x3b, 0x09, 0xee, 0x82, 0xc4, 0x7d, 0x6e, 0x9c, 0x24, 0xb9, 0x47, 0xbe, 0x13, 0x03, 0xf6, 0x34,
	0x28, 0x72, 0x26, 0x7c, 0x04, 0xf3, 0x09, 0x3d, 0xc7, 0x3f, 0x37, 0x28, 0xf1, 0xcf, 0x0d, 0x14,
	0xd6, 0x35, 0x43, 0x93, 0xbd, 0xbd, 0x6a, 0xb0, 0x33, 0x35, 0x47, 0xf3, 0xf4, 0x30, 0xea, 0x9a,
	0xcd, 0xd3, 0x43, 0xbc, 0x06, 0xf3, 0x09, 0xa5, 0xc7, 0x6c, 0x4a, 0xcc, 0x86, 0x5b, 0x30, 0x9f,
	0xd0, 0x6d, 0xa2, 0x3c, 0x1d, 0xf2, 0xe7, 0xc6, 0x49, 0x64, 0xea, 0x73, 0xe3, 0x84, 0xba, 0xc6,
	0x27, 0xd6, 0xc8, 0x0f, 0xec, 0x4b, 0x22, 0x64, 0xc6, 0x00, 0xbc, 0x03, 0xc0, 0x23, 0x83, 0xb9,
	0x11, 0x49, 0x33, 0x5d, 0x59, 0x0c, 0x72, 0x19, 0xe7, 0xd1, 0x1e, 0xbf, 0xf0, 0x4b, 0xb7, 0x6b,
	0xf7, 0xae, 0xd9, 0xbc, 0x77, 0x97, 0xd6, 0xb4, 0x03, 0x15, 0x93, 0x45, 0x0d, 0x33, 0xbf, 0xe8,
	0x1c, 0xbc, 0x66, 0xc7, 0xd1, 0xf4, 0x72, 0xce, 0x00, 0x33, 0x8e, 0xad, 0x1d, 0xda, 0x62, 0xa9,
	0x8a, 0x9c, 0x27, 0x2f, 0xf1, 0xc4, 0xaa, 0x53, 0x9e, 0xee, 0xf8, 0x6b, 0xef, 0x1e, 0x54, 0x07,
	0x54, 0x43, 0xdb, 0x32, 0x69, 0x13, 0xc6, 0xbf, 0x87, 0xda, 0xbe, 0xeb, 0x25, 0xf4, 0x5d, 0x81,
	0x7c, 0xe0, 0x5b, 0xd9, 0xf1, 0x95, 0x42, 0x29, 0xb2, 0x1b, 0x44, 0x0b, 0x92, 0x8c, 0xec, 0x06,
	0x61, 0x32, 0xd8, 0xf3, 0x53, 0x82, 0x5d, 0x8d, 0xed, 0xb5, 0x0b, 0xf7, 0xbe, 0x21, 0xa1, 0x2c,
	0xfb, 0x86, 0xd9, 0x39, 0xe3, 0x44, 0x69, 0x80, 0xbc, 0xfd, 0x35, 0xf8, 0x80, 0x0f, 0x90, 0x77,
	0x10, 0x4c, 0xfd, 0x3f, 0x1a, 0xff, 0x9c, 0xc0, 0xce, 0x78, 0x1b, 0x6a, 0xdf, 0x99, 0xce, 0xdb,
	0x3b, 0xc8, 0x7d, 0x0d, 0xb5, 0x6f, 0x1c, 0xb7, 0x73, 0xe7, 0xe0, 0xa8, 0x43, 0xc9, 0x33, 0xc3,
	0x90, 0xf8, 0xd1, 0x1c, 0x15, 0x7d, 0xe2, 0x2b, 0xa8, 0x1d, 0xd8, 0xbd, 0x9e, 0x7c, 0xe3, 0x87,
	0xa0, 0x0d, 0x09, 0xaf, 0x20, 0x59, 0x3d, 0x4a, 0x43, 0xc2, 0x12, 0x93, 0x52, 0xb9, 0x4e, 0x22,
	0xd8, 0x64, 0x2a, 0xd7, 0xe1, 0x11, 0x56, 0x87, 0x52, 0xd0, 0x37, 0x1d, 0xc7, 0xbd, 0x12, 0xee,
	0x8c, 0x3e, 0x71, 0x0f, 0xf4, 0x58, 0xb0, 0x18, 0xb5, 0xd7, 0x33, 0x92, 0xe3, 0xc5, 0x86, 0x8d,
	0x1c, 0x63, 0xe9, 0xeb, 0x19, 0xe9, 0x69, 0x4a, 0xa1, 0x01, 0x5e, 0x85, 0xca, 0x61, 0x60, 0xbd,
	0x8d, 0x1e, 0xa7, 0x43, 0xbe, 0x67, 0xff, 0x56, 0x14, 0x52, 0x7a, 0xc4, 0x4f, 0xa1, 0xca, 0x09,
	0x84, 0x12, 0x12, 0x45, 0x99, 0x51, 0xb0, 0x41, 0xd2, 0xf7, 0x5d, 0x5f, 0xd8, 0x8e, 0x7f, 0xe0,
	0xa7, 0x70, 0x9f, 0x77, 0x54, 0x2a, 0x26, 0x20, 0xe1, 0xf8, 0x82, 0x0f, 0x00, 0x7a, 0x1c, 0xd4,
	0xb6, 0xbb, 0xe2, 0x9e, 0xb2, 0x80, 0x1c, 0x75, 0xf1, 0x39, 0x2c, 0x1a, 0x44, 0xbc, 0x83, 0xb1,
	0x45, 0x9e, 0x9f, 0xc5, 0x85, 0x56, 0xa1, 0x12, 0x86, 0x4e, 0x3b, 0x20, 0x96, 0x3b, 0xec, 0x06,
	0x4c, 0x93, 0xbc, 0x01, 0x61, 0xe8, 0xb4, 0x38, 0x04, 0x7f, 0x07, 0x0b, 0xbb, 0xdd, 0x6e, 0xea,
	0xd2, 0x5b, 0x05, 0x47, 0x52, 0x72, 0x2e, 0xad, 0xef, 0x33, 0x58, 0x10, 0x39, 0x76, 0xc7, 0x8b,
	0xf1, 0x7d, 0x58, 0xdc, 0xb5, 0x42, 0xfb, 0xd2, 0x0c, 0xc9, 0xee, 0x28, 0x8c, 0x7a, 0x23, 0x5e,
	0x86, 0xa5, 0x24, 0x98, 0xdb, 0x6d, 0x63, 0x03, 0x20, 0xfe, 0xc9, 0x0b, 0x69, 0xa0, 0x9e, 0xb7,
	0x9a, 0x86, 0x3e, 0x47, 0x4f, 0xbb, 0xe7, 0x67, 0xa7, 0xba, 0x42, 0x4f, 0x87, 0xad, 0xfd, 0x6f,
	0xf5, 0xdc, 0xc6, 0x27, 0x7c, 0x5d, 0x66, 0x3b, 0x6e, 0x15, 0x34, 0xa3, 0xd9, 0x6a, 0x1a, 0x6f,
	0x9a, 0x07, 0x9c, 0xfa, 0xf0, 0xe8, 0xa4, 0xa9, 0x2b, 0xa8, 0x04, 0xf9, 0x83, 0x23, 0x43, 0xcf,
	0x6d, 0x3c, 0x89, 0xa6, 0x5b, 0x36, 0x4d, 0xa1, 0x0a, 0x94, 0x5a, 0x67, 0xbb, 0xc6, 0x19, 0x23,
	0x2f, 0x43, 0xc1, 0x68, 0xee, 0x1e, 0xfc, 0x5a, 0x57, 0xe8, 0x3d, 0x87, 0x47, 0xaf, 0x8e, 0x5a,
	0x2f, 0x9b, 0x07, 0x7a, 0x6e, 0xe3, 0x39, 0x94, 0x0f, 0x88, 0x63, 0x0f, 0xec, 0x90, 0xf8, 0xf4,
	0xd2, 0x57, 0xa7, 0xaf, 0x9a, 0xfc, 0xfa, 0xe3, 0xd6, 0xe9, 0x2b, 0xae, 0xcc, 0xc9, 0xd1, 0xab,
	0xa6, 0x9e, 0xa3, 0x82, 0x5a, 0xbf, 0x3a, 0xd1, 0xf3, 0xf4, 0xb0, 0xdf, 0x7a, 0xa3, 0xab, 0x3b,
	0x7f, 0xae, 0x41, 0x7e, 0xf7, 0xf5, 0x11, 0xfa, 0x0a, 0x20, 0xde, 0x88, 0xd1, 0x32, 0x37, 0x52,
	0x7a, 0x45, 0x6e, 0x2c, 0x67, 0x56, 0xee, 0x26, 0x5b, 0x55, 0xe6, 0xd0, 0x67, 0x50, 0x91, 0xb6,
	0x5b, 0xf4, 0x80, 0x5d, 0x90, 0xdd, 0x77, 0x1b, 0xc9, 0x85, 0x14, 0xcf, 0xa1, 0xcf, 0x41, 0x8b,
	0x16, 0x59, 0xb4, 0xc4, 0x90, 0xa9, 0x85, 0xb7, 0x71, 0x3f, 0x05, 0xe5, 0x4e, 0xc0, 0x73, 0x54,
	0xe7, 0x78, 0x87, 0x15, 0x3a, 0x67, 0x96, 0xda, 0x19, 0x3a, 0x7f, 0x0a, 0x15, 0x69, 0x4d, 0x15,
	0x3a, 0x67, 0x17, 0xd7, 0x86, 0x1c, 0x32, 0x78, 0x0e, 0xed, 0x41, 0x55, 0x5e, 0x15, 0x51, 0x5d,
	0xe4, 0x73, 0x66, 0x7b, 0x9c, 0x21, 0xfa, 0x4b, 0x98, 0x4f, 0xec, 0x76, 0xe8, 0xa1, 0x6c, 0xb0,
	0xe4, 0x2d, 0xe9, 0x75, 0x86, 0x19, 0x0d, 0xe2, 0x4d, 0x4d, 0xbc, 0x3c, 0xb3, 0xba, 0x4d, 0x60,
	0xdc, 0x56, 0xa8, 0xf6, 0xf2, 0xfe, 0x23, 0xb4, 0x9f, 0xb0, 0x12, 0xcd, 0xd0, 0xfe, 0x39, 0x54,
	0xa4, 0x3d, 0x48, 0x18, 0x2e, 0xbb, 0x19, 0x4d, 0x56, 0x60, 0x1f, 0x6a, 0xa9, 0x05, 0x07, 0xad,
	0x70, 0x1d, 0x26, 0xae, 0x3d, 0x93, 0x2f, 0xf9, 0x1a, 0x2a, 0xd2, 0x82, 0x21, 0x34, 0xc8, 0xae,
	0x1c, 0x33, 0xde, 0xb0, 0x07, 0x55, 0x79, 0xcd, 0x10, 0x76, 0x98, 0xb0, 0x79, 0xdc, 0xca, 0x8b,
	0xe2, 0x92, 0x84, 0x17, 0x93, 0xb7, 0xa4, 0x7f, 0xe4, 0xc7, 0x73, 0xe8, 0x19, 0xf7, 0xa2, 0xe0,
	0x8d, 0xbd, 0x98, 0x64, 0xd4, 0x53, 0x8c, 0x01, 0x57, 0x5e, 0x9e, 0xe5, 0x85, 0xf2, 0x13, 0xc6,
	0xfb, 0x19, 0xca, 0x7f, 0x0d, 0x10, 0x0f, 0x70, 0x42, 0x7a, 0x66, 0xa2, 0x9b, 0xce, 0xbf, 0xae,
	0xa0, 0x2f, 0x40, 0x8b, 0x06, 0x2a, 0x91, 0xba, 0xa9, 0xf9, 0x6a, 0x86, 0xf4, 0x17, 0x50, 0x12,
	0xb5, 0x1a, 0x2d, 0x32, 0xd6, 0xe4, 0x74, 0xd4, 0x58, 0xc9, 0x70, 0xb2, 0x9f, 0x4a, 0xde, 0x98,
	0xce, 0x88, 0xb0, 0x08, 0x88, 0x0b, 0x0e, 0xbb, 0x24, 0x51, 0x70, 0xe4, 0x8b, 0x92, 0xdd, 0x16,
	0xcf, 0xa1, 0x27, 0xbc, 0xe0, 0x48, 0x5a, 0xa7, 0x06, 0xa4, 0x0c, 0xcb, 0xb6, 0x42, 0x99, 0xa2,
	0x01, 0x48, 0x30, 0xa5, 0xe6, 0xa1, 0x29, 0x4c, 0xd1, 0x0c, 0x24, 0x98, 0x52, 0x23, 0xd1, 0x24,
	0xa6, 0xe7, 0xa0, 0x45, 0xd3, 0x86, 0x60, 0x4a, 0x4d, 0x3d, 0xa2, 0x1e, 0xa6, 0x47, 0x12, 0xc6,
	0xdc, 0x84, 0xaa, 0xdc, 0xb0, 0x44, 0x5c, 0x4c, 0x68, 0x6d, 0x8d, 0x87, 0x13, 0x30, 0xe3, 0xc2,
	0xfa, 0x25, 0xeb, 0x28, 0x24, 0x24, 0xbb, 0x8e, 0x83, 0xa6, 0xf8, 0x70, 0x86, 0x6f, 0xb7, 0x40,
	0xa5, 0x73, 0x0a, 0xe2, 0x91, 0x2b, 0xcd, 0x34, 0x8d, 0x05, 0x09, 0x22, 0xa9, 0xfd, 0x15, 0x40,
	0x3c, 0x11, 0x88, 0x50, 0xcc, 0x8c, 0x08, 0x33, 0x73, 0x19, 0xe2, 0xc6, 0x2f, 0xf8, 0x33, 0x93,
	0x40, 0xa3, 0x21, 0x65, 0x78, 0x6a, 0x12, 0xc2, 0x73, 0xe8, 0x1b, 0x98, 0x4f, 0xa0, 0xa6, 0x66,
	0xc4, 0xcc, 0x6b, 0xd6, 0x59, 0x81, 0x95, 0xa7, 0x26, 0xe1, 0x83, 0x09, 0x83, 0xd4, 0xf4, 0x07,
	0xed, 0x7d, 0xf6, 0xf7, 0x77, 0x8f, 0x94, 0x7f, 0xbe, 0x7b, 0xa4, 0xfc, 0xfb, 0xdd, 0x23, 0xe5,
	0xfb, 0x8f, 0x2f, 0xec, 0xb0, 0x3f, 0xea, 0x6c, 0x5a, 0xee, 0x60, 0xcb, 0x33, 0xad, 0xfe, 0x75,
	0x97, 0xf8, 0xf2, 0xe9, 0x72, 0x67, 0x2b, 0xf0, 0xad, 0x2d, 0xaf, 0x17, 0x74, 0x8a, 0xec, 0xaa,
	0x27, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x4e, 0xc0, 0x81, 0x48, 0x15, 0x20, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type APIClient interface {
	// CreateRepo creates a new repo.
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (*ListRepoResponse, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error)
	// ListCommit returns info about all commits.
	ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (API_ListCommitClient, error)
	// SquashCommit squashes a commit into it's parent.
	SquashCommit(ctx context.Context, in *SquashCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// FlushCommit waits for downstream commits to finish.
	FlushCommit(ctx context.Context, in *FlushCommitRequest, opts ...grpc.CallOption) (API_FlushCommitClient, error)
	// SubscribeCommit subscribes for new commits on a given branch.
	SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error)
	// ClearCommit removes all data from the commit.
	ClearCommit(ctx context.Context, in *ClearCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// CreateBranch creates a new branch.
	CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectBranch returns info about a branch.
	InspectBranch(ctx context.Context, in *InspectBranchRequest, opts ...grpc.CallOption) (*BranchInfo, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (*BranchInfos, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// ModifyFile performs modifications on a set of files.
	ModifyFile(ctx context.Context, opts ...grpc.CallOption) (API_ModifyFileClient, error)
	// CopyFile copies the contents of one file to another.
	// TODO: Make this a part of ModifyFile.
	CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// GetFile returns a byte stream of the contents of the file.
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error)
	// InspectFile returns info about a file.
	InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error)
	// ListFile returns info about all files.
	ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileClient, error)
	// WalkFile walks over all the files under a directory, including children of children.
	WalkFile(ctx context.Context, in *WalkFileRequest, opts ...grpc.CallOption) (API_WalkFileClient, error)
	// GlobFile returns info about all files.
	GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (API_GlobFileClient, error)
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (API_DiffFileClient, error)
	// ActivateAuth creates a role binding for all existing repos
	ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error)
	// DeleteAll deletes everything.
	DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	// Fsck does a file system consistency check for pfs.
	Fsck(ctx context.Context, in *FsckRequest, opts ...grpc.CallOption) (API_FsckClient, error)
	// Fileset API
	// AddFileset associates a fileset with a commit
	AddFileset(ctx context.Context, in *AddFilesetRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// GetFileset returns a fileset with the data from a commit
	GetFileset(ctx context.Context, in *GetFilesetRequest, opts ...grpc.CallOption) (*CreateFilesetResponse, error)
	// CreateFileset creates a new fileset.
	CreateFileset(ctx context.Context, opts ...grpc.CallOption) (API_CreateFilesetClient, error)
	// RenewFileset prevents a fileset from being deleted for a set amount of time.
	RenewFileset(ctx context.Context, in *RenewFilesetRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/CreateRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error) {
	out := new(RepoInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (*ListRepoResponse, error) {
	out := new(ListRepoResponse)
	err := c.cc.Invoke(ctx, "/pfs.API/ListRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error) {
	out := new(Commit)
	err := c.cc.Invoke(ctx, "/pfs.API/StartCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/FinishCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error) {
	out := new(CommitInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (API_ListCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[0], "/pfs.API/ListCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIListCommitClient struct {
	grpc.ClientStream
}

func (x *aPIListCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SquashCommit(ctx context.Context, in *SquashCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/SquashCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FlushCommit(ctx context.Context, in *FlushCommitRequest, opts ...grpc.CallOption) (API_FlushCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[1], "/pfs.API/FlushCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFlushCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FlushCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIFlushCommitClient struct {
	grpc.ClientStream
}

func (x *aPIFlushCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[2], "/pfs.API/SubscribeCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPISubscribeCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_SubscribeCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPISubscribeCommitClient struct {
	grpc.ClientStream
}

func (x *aPISubscribeCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ClearCommit(ctx context.Context, in *ClearCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/ClearCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/CreateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectBranch(ctx context.Context, in *InspectBranchRequest, opts ...grpc.CallOption) (*BranchInfo, error) {
	out := new(BranchInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (*BranchInfos, error) {
	out := new(BranchInfos)
	err := c.cc.Invoke(ctx, "/pfs.API/ListBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ModifyFile(ctx context.Context, opts ...grpc.CallOption) (API_ModifyFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[3], "/pfs.API/ModifyFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIModifyFileClient{stream}
	return x, nil
}

type API_ModifyFileClient interface {
	Send(*ModifyFileRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type aPIModifyFileClient struct {
	grpc.ClientStream
}

func (x *aPIModifyFileClient) Send(m *ModifyFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIModifyFileClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) CopyFile(ctx context.Context, in *CopyFileRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/CopyFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[4], "/pfs.API/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetFileClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type aPIGetFileClient struct {
	grpc.ClientStream
}

func (x *aPIGetFileClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, "/pfs.API/InspectFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[5], "/pfs.API/ListFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIListFileClient struct {
	grpc.ClientStream
}

func (x *aPIListFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) WalkFile(ctx context.Context, in *WalkFileRequest, opts ...grpc.CallOption) (API_WalkFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[6], "/pfs.API/WalkFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIWalkFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_WalkFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIWalkFileClient struct {
	grpc.ClientStream
}

func (x *aPIWalkFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (API_GlobFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[7], "/pfs.API/GlobFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGlobFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GlobFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIGlobFileClient struct {
	grpc.ClientStream
}

func (x *aPIGlobFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (API_DiffFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[8], "/pfs.API/DiffFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIDiffFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_DiffFileClient interface {
	Recv() (*DiffFileResponse, error)
	grpc.ClientStream
}

type aPIDiffFileClient struct {
	grpc.ClientStream
}

func (x *aPIDiffFileClient) Recv() (*DiffFileResponse, error) {
	m := new(DiffFileResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error) {
	out := new(ActivateAuthResponse)
	err := c.cc.Invoke(ctx, "/pfs.API/ActivateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/DeleteAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Fsck(ctx context.Context, in *FsckRequest, opts ...grpc.CallOption) (API_FsckClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[9], "/pfs.API/Fsck", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFsckClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FsckClient interface {
	Recv() (*FsckResponse, error)
	grpc.ClientStream
}

type aPIFsckClient struct {
	grpc.ClientStream
}

func (x *aPIFsckClient) Recv() (*FsckResponse, error) {
	m := new(FsckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) AddFileset(ctx context.Context, in *AddFilesetRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/AddFileset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetFileset(ctx context.Context, in *GetFilesetRequest, opts ...grpc.CallOption) (*CreateFilesetResponse, error) {
	out := new(CreateFilesetResponse)
	err := c.cc.Invoke(ctx, "/pfs.API/GetFileset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateFileset(ctx context.Context, opts ...grpc.CallOption) (API_CreateFilesetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[10], "/pfs.API/CreateFileset", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPICreateFilesetClient{stream}
	return x, nil
}

type API_CreateFilesetClient interface {
	Send(*ModifyFileRequest) error
	CloseAndRecv() (*CreateFilesetResponse, error)
	grpc.ClientStream
}

type aPICreateFilesetClient struct {
	grpc.ClientStream
}

func (x *aPICreateFilesetClient) Send(m *ModifyFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPICreateFilesetClient) CloseAndRecv() (*CreateFilesetResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CreateFilesetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) RenewFileset(ctx context.Context, in *RenewFilesetRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs.API/RenewFileset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIServer is the server API for API service.
type APIServer interface {
	// CreateRepo creates a new repo.
	CreateRepo(context.Context, *CreateRepoRequest) (*types.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(context.Context, *InspectRepoRequest) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(context.Context, *ListRepoRequest) (*ListRepoResponse, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(context.Context, *DeleteRepoRequest) (*types.Empty, error)
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(context.Context, *StartCommitRequest) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(context.Context, *FinishCommitRequest) (*types.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(context.Context, *InspectCommitRequest) (*CommitInfo, error)
	// ListCommit returns info about all commits.
	ListCommit(*ListCommitRequest, API_ListCommitServer) error
	// SquashCommit squashes a commit into it's parent.
	SquashCommit(context.Context, *SquashCommitRequest) (*types.Empty, error)
	// FlushCommit waits for downstream commits to finish.
	FlushCommit(*FlushCommitRequest, API_FlushCommitServer) error
	// SubscribeCommit subscribes for new commits on a given branch.
	SubscribeCommit(*SubscribeCommitRequest, API_SubscribeCommitServer) error
	// ClearCommit removes all data from the commit.
	ClearCommit(context.Context, *ClearCommitRequest) (*types.Empty, error)
	// CreateBranch creates a new branch.
	CreateBranch(context.Context, *CreateBranchRequest) (*types.Empty, error)
	// InspectBranch returns info about a branch.
	InspectBranch(context.Context, *InspectBranchRequest) (*BranchInfo, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(context.Context, *ListBranchRequest) (*BranchInfos, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(context.Context, *DeleteBranchRequest) (*types.Empty, error)
	// ModifyFile performs modifications on a set of files.
	ModifyFile(API_ModifyFileServer) error
	// CopyFile copies the contents of one file to another.
	// TODO: Make this a part of ModifyFile.
	CopyFile(context.Context, *CopyFileRequest) (*types.Empty, error)
	// GetFile returns a byte stream of the contents of the file.
	GetFile(*GetFileRequest, API_GetFileServer) error
	// InspectFile returns info about a file.
	InspectFile(context.Context, *InspectFileRequest) (*FileInfo, error)
	// ListFile returns info about all files.
	ListFile(*ListFileRequest, API_ListFileServer) error
	// WalkFile walks over all the files under a directory, including children of children.
	WalkFile(*WalkFileRequest, API_WalkFileServer) error
	// GlobFile returns info about all files.
	GlobFile(*GlobFileRequest, API_GlobFileServer) error
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(*DiffFileRequest, API_DiffFileServer) error
	// ActivateAuth creates a role binding for all existing repos
	ActivateAuth(context.Context, *ActivateAuthRequest) (*ActivateAuthResponse, error)
	// DeleteAll deletes everything.
	DeleteAll(context.Context, *types.Empty) (*types.Empty, error)
	// Fsck does a file system consistency check for pfs.
	Fsck(*FsckRequest, API_FsckServer) error
	// Fileset API
	// AddFileset associates a fileset with a commit
	AddFileset(context.Context, *AddFilesetRequest) (*types.Empty, error)
	// GetFileset returns a fileset with the data from a commit
	GetFileset(context.Context, *GetFilesetRequest) (*CreateFilesetResponse, error)
	// CreateFileset creates a new fileset.
	CreateFileset(API_CreateFilesetServer) error
	// RenewFileset prevents a fileset from being deleted for a set amount of time.
	RenewFileset(context.Context, *RenewFilesetRequest) (*types.Empty, error)
}

// UnimplementedAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAPIServer struct {
}

func (*UnimplementedAPIServer) CreateRepo(ctx context.Context, req *CreateRepoRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRepo not implemented")
}
func (*UnimplementedAPIServer) InspectRepo(ctx context.Context, req *InspectRepoRequest) (*RepoInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectRepo not implemented")
}
func (*UnimplementedAPIServer) ListRepo(ctx context.Context, req *ListRepoRequest) (*ListRepoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRepo not implemented")
}
func (*UnimplementedAPIServer) DeleteRepo(ctx context.Context, req *DeleteRepoRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRepo not implemented")
}
func (*UnimplementedAPIServer) StartCommit(ctx context.Context, req *StartCommitRequest) (*Commit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCommit not implemented")
}
func (*UnimplementedAPIServer) FinishCommit(ctx context.Context, req *FinishCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishCommit not implemented")
}
func (*UnimplementedAPIServer) InspectCommit(ctx context.Context, req *InspectCommitRequest) (*CommitInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectCommit not implemented")
}
func (*UnimplementedAPIServer) ListCommit(req *ListCommitRequest, srv API_ListCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method ListCommit not implemented")
}
func (*UnimplementedAPIServer) SquashCommit(ctx context.Context, req *SquashCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SquashCommit not implemented")
}
func (*UnimplementedAPIServer) FlushCommit(req *FlushCommitRequest, srv API_FlushCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method FlushCommit not implemented")
}
func (*UnimplementedAPIServer) SubscribeCommit(req *SubscribeCommitRequest, srv API_SubscribeCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCommit not implemented")
}
func (*UnimplementedAPIServer) ClearCommit(ctx context.Context, req *ClearCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearCommit not implemented")
}
func (*UnimplementedAPIServer) CreateBranch(ctx context.Context, req *CreateBranchRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBranch not implemented")
}
func (*UnimplementedAPIServer) InspectBranch(ctx context.Context, req *InspectBranchRequest) (*BranchInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectBranch not implemented")
}
func (*UnimplementedAPIServer) ListBranch(ctx context.Context, req *ListBranchRequest) (*BranchInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBranch not implemented")
}
func (*UnimplementedAPIServer) DeleteBranch(ctx context.Context, req *DeleteBranchRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBranch not implemented")
}
func (*UnimplementedAPIServer) ModifyFile(srv API_ModifyFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ModifyFile not implemented")
}
func (*UnimplementedAPIServer) CopyFile(ctx context.Context, req *CopyFileRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyFile not implemented")
}
func (*UnimplementedAPIServer) GetFile(req *GetFileRequest, srv API_GetFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (*UnimplementedAPIServer) InspectFile(ctx context.Context, req *InspectFileRequest) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectFile not implemented")
}
func (*UnimplementedAPIServer) ListFile(req *ListFileRequest, srv API_ListFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ListFile not implemented")
}
func (*UnimplementedAPIServer) WalkFile(req *WalkFileRequest, srv API_WalkFileServer) error {
	return status.Errorf(codes.Unimplemented, "method WalkFile not implemented")
}
func (*UnimplementedAPIServer) GlobFile(req *GlobFileRequest, srv API_GlobFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GlobFile not implemented")
}
func (*UnimplementedAPIServer) DiffFile(req *DiffFileRequest, srv API_DiffFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DiffFile not implemented")
}
func (*UnimplementedAPIServer) ActivateAuth(ctx context.Context, req *ActivateAuthRequest) (*ActivateAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateAuth not implemented")
}
func (*UnimplementedAPIServer) DeleteAll(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAll not implemented")
}
func (*UnimplementedAPIServer) Fsck(req *FsckRequest, srv API_FsckServer) error {
	return status.Errorf(codes.Unimplemented, "method Fsck not implemented")
}
func (*UnimplementedAPIServer) AddFileset(ctx context.Context, req *AddFilesetRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFileset not implemented")
}
func (*UnimplementedAPIServer) GetFileset(ctx context.Context, req *GetFilesetRequest) (*CreateFilesetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileset not implemented")
}
func (*UnimplementedAPIServer) CreateFileset(srv API_CreateFilesetServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateFileset not implemented")
}
func (*UnimplementedAPIServer) RenewFileset(ctx context.Context, req *RenewFilesetRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenewFileset not implemented")
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectRepo(ctx, req.(*InspectRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListRepo(ctx, req.(*ListRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteRepo(ctx, req.(*DeleteRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/StartCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartCommit(ctx, req.(*StartCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FinishCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).FinishCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/FinishCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).FinishCommit(ctx, req.(*FinishCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectCommit(ctx, req.(*InspectCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListCommit(m, &aPIListCommitServer{stream})
}

type API_ListCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIListCommitServer struct {
	grpc.ServerStream
}

func (x *aPIListCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SquashCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SquashCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).SquashCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/SquashCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).SquashCommit(ctx, req.(*SquashCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FlushCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FlushCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).FlushCommit(m, &aPIFlushCommitServer{stream})
}

type API_FlushCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIFlushCommitServer struct {
	grpc.ServerStream
}

func (x *aPIFlushCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SubscribeCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).SubscribeCommit(m, &aPISubscribeCommitServer{stream})
}

type API_SubscribeCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPISubscribeCommitServer struct {
	grpc.ServerStream
}

func (x *aPISubscribeCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ClearCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ClearCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ClearCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ClearCommit(ctx, req.(*ClearCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CreateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateBranch(ctx, req.(*CreateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectBranch(ctx, req.(*InspectBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ListBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListBranch(ctx, req.(*ListBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteBranch(ctx, req.(*DeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ModifyFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).ModifyFile(&aPIModifyFileServer{stream})
}

type API_ModifyFileServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*ModifyFileRequest, error)
	grpc.ServerStream
}

type aPIModifyFileServer struct {
	grpc.ServerStream
}

func (x *aPIModifyFileServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIModifyFileServer) Recv() (*ModifyFileRequest, error) {
	m := new(ModifyFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_CopyFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CopyFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/CopyFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CopyFile(ctx, req.(*CopyFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetFile(m, &aPIGetFileServer{stream})
}

type API_GetFileServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type aPIGetFileServer struct {
	grpc.ServerStream
}

func (x *aPIGetFileServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/InspectFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectFile(ctx, req.(*InspectFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListFile(m, &aPIListFileServer{stream})
}

type API_ListFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIListFileServer struct {
	grpc.ServerStream
}

func (x *aPIListFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_WalkFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WalkFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).WalkFile(m, &aPIWalkFileServer{stream})
}

type API_WalkFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIWalkFileServer struct {
	grpc.ServerStream
}

func (x *aPIWalkFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GlobFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GlobFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GlobFile(m, &aPIGlobFileServer{stream})
}

type API_GlobFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIGlobFileServer struct {
	grpc.ServerStream
}

func (x *aPIGlobFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DiffFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DiffFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).DiffFile(m, &aPIDiffFileServer{stream})
}

type API_DiffFileServer interface {
	Send(*DiffFileResponse) error
	grpc.ServerStream
}

type aPIDiffFileServer struct {
	grpc.ServerStream
}

func (x *aPIDiffFileServer) Send(m *DiffFileResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ActivateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ActivateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/ActivateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ActivateAuth(ctx, req.(*ActivateAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Fsck_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FsckRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).Fsck(m, &aPIFsckServer{stream})
}

type API_FsckServer interface {
	Send(*FsckResponse) error
	grpc.ServerStream
}

type aPIFsckServer struct {
	grpc.ServerStream
}

func (x *aPIFsckServer) Send(m *FsckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_AddFileset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFilesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AddFileset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/AddFileset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AddFileset(ctx, req.(*AddFilesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetFileset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFilesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetFileset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/GetFileset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetFileset(ctx, req.(*GetFilesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateFileset_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).CreateFileset(&aPICreateFilesetServer{stream})
}

type API_CreateFilesetServer interface {
	SendAndClose(*CreateFilesetResponse) error
	Recv() (*ModifyFileRequest, error)
	grpc.ServerStream
}

type aPICreateFilesetServer struct {
	grpc.ServerStream
}

func (x *aPICreateFilesetServer) SendAndClose(m *CreateFilesetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPICreateFilesetServer) Recv() (*ModifyFileRequest, error) {
	m := new(ModifyFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_RenewFileset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewFilesetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RenewFileset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs.API/RenewFileset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RenewFileset(ctx, req.(*RenewFilesetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pfs.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRepo",
			Handler:    _API_CreateRepo_Handler,
		},
		{
			MethodName: "InspectRepo",
			Handler:    _API_InspectRepo_Handler,
		},
		{
			MethodName: "ListRepo",
			Handler:    _API_ListRepo_Handler,
		},
		{
			MethodName: "DeleteRepo",
			Handler:    _API_DeleteRepo_Handler,
		},
		{
			MethodName: "StartCommit",
			Handler:    _API_StartCommit_Handler,
		},
		{
			MethodName: "FinishCommit",
			Handler:    _API_FinishCommit_Handler,
		},
		{
			MethodName: "InspectCommit",
			Handler:    _API_InspectCommit_Handler,
		},
		{
			MethodName: "SquashCommit",
			Handler:    _API_SquashCommit_Handler,
		},
		{
			MethodName: "ClearCommit",
			Handler:    _API_ClearCommit_Handler,
		},
		{
			MethodName: "CreateBranch",
			Handler:    _API_CreateBranch_Handler,
		},
		{
			MethodName: "InspectBranch",
			Handler:    _API_InspectBranch_Handler,
		},
		{
			MethodName: "ListBranch",
			Handler:    _API_ListBranch_Handler,
		},
		{
			MethodName: "DeleteBranch",
			Handler:    _API_DeleteBranch_Handler,
		},
		{
			MethodName: "CopyFile",
			Handler:    _API_CopyFile_Handler,
		},
		{
			MethodName: "InspectFile",
			Handler:    _API_InspectFile_Handler,
		},
		{
			MethodName: "ActivateAuth",
			Handler:    _API_ActivateAuth_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
		{
			MethodName: "AddFileset",
			Handler:    _API_AddFileset_Handler,
		},
		{
			MethodName: "GetFileset",
			Handler:    _API_GetFileset_Handler,
		},
		{
			MethodName: "RenewFileset",
			Handler:    _API_RenewFileset_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListCommit",
			Handler:       _API_ListCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FlushCommit",
			Handler:       _API_FlushCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeCommit",
			Handler:       _API_SubscribeCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ModifyFile",
			Handler:       _API_ModifyFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _API_GetFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListFile",
			Handler:       _API_ListFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WalkFile",
			Handler:       _API_WalkFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GlobFile",
			Handler:       _API_GlobFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DiffFile",
			Handler:       _API_DiffFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Fsck",
			Handler:       _API_Fsck_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateFileset",
			Handler:       _API_CreateFileset_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "pfs/pfs.proto",
}

func (m *Repo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Repo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Branch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Branch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Branch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Branches) > 0 {
		for iNdEx := len(m.Branches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Branches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.AuthInfo != nil {
		{
			size, err := m.AuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepoAuthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoAuthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepoAuthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Permissions) > 0 {
		dAtA7 := make([]byte, len(m.Permissions)*10)
		var j6 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintPfs(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BranchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BranchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DirectProvenance) > 0 {
		for iNdEx := len(m.DirectProvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DirectProvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Subvenance) > 0 {
		for iNdEx := len(m.Subvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BranchInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BranchInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BranchInfo) > 0 {
		for iNdEx := len(m.BranchInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BranchInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Trigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commits != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Commits))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Size_) > 0 {
		i -= len(m.Size_)
		copy(dAtA[i:], m.Size_)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Size_)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CronSpec) > 0 {
		i -= len(m.CronSpec)
		copy(dAtA[i:], m.CronSpec)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.CronSpec)))
		i--
		dAtA[i] = 0x1a
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitOrigin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitOrigin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitOrigin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Upper != nil {
		{
			size, err := m.Upper.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Lower != nil {
		{
			size, err := m.Lower.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitProvenance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitProvenance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitProvenance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubvenantCommitsTotal != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SubvenantCommitsTotal))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.SubvenantCommitsFailure != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SubvenantCommitsFailure))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.SubvenantCommitsSuccess != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SubvenantCommitsSuccess))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.ReadyProvenance != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.ReadyProvenance))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ChildCommits) > 0 {
		for iNdEx := len(m.ChildCommits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChildCommits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.Subvenance) > 0 {
		for iNdEx := len(m.Subvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x42
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ParentCommit != nil {
		{
			size, err := m.ParentCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Committed != nil {
		{
			size, err := m.Committed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.FileType != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Update {
		i--
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ListRepoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRepoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRepoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RepoInfo) > 0 {
		for iNdEx := len(m.RepoInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RepoInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x30
	}
	if m.Empty {
		i--
		if m.Empty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BlockState != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.BlockState))
		i--
		dAtA[i] = 0x10
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Number != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x20
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CommitInfo) > 0 {
		for iNdEx := len(m.CommitInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommitInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SquashCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SquashCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SquashCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FlushCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlushCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlushCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ToRepos) > 0 {
		for iNdEx := len(m.ToRepos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ToRepos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Commits) > 0 {
		for iNdEx := len(m.Commits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Prov != nil {
		{
			size, err := m.Prov.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.State != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SBranch) > 0 {
		i -= len(m.SBranch)
		copy(dAtA[i:], m.SBranch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.SBranch)))
		i--
		dAtA[i] = 0x12
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source != nil {
		{
			size := m.Source.Size()
			i -= size
			if _, err := m.Source.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x12
	}
	if m.Overwrite {
		i--
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendFile_RawFileSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFile_RawFileSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RawFileSource != nil {
		{
			size, err := m.RawFileSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AppendFile_TarFileSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFile_TarFileSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TarFileSource != nil {
		{
			size, err := m.TarFileSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AppendFile_UrlFileSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendFile_UrlFileSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UrlFileSource != nil {
		{
			size, err := m.UrlFileSource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *RawFileSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawFileSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawFileSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EOF {
		i--
		if m.EOF {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TarFileSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TarFileSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TarFileSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *URLFileSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *URLFileSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *URLFileSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Recursive {
		i--
		if m.Recursive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModifyFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Modification != nil {
		{
			size := m.Modification.Size()
			i -= size
			if _, err := m.Modification.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModifyFileRequest_AppendFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest_AppendFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AppendFile != nil {
		{
			size, err := m.AppendFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ModifyFileRequest_DeleteFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest_DeleteFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteFile != nil {
		{
			size, err := m.DeleteFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *CopyFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x22
	}
	if m.Overwrite {
		i--
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Dst != nil {
		{
			size, err := m.Dst.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x12
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Full {
		i--
		if m.Full {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalkFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalkFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalkFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiffFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiffFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Shallow {
		i--
		if m.Shallow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.OldFile != nil {
		{
			size, err := m.OldFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewFile != nil {
		{
			size, err := m.NewFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiffFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiffFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OldFile != nil {
		{
			size, err := m.OldFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewFile != nil {
		{
			size, err := m.NewFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FsckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Fix {
		i--
		if m.Fix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FsckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fix) > 0 {
		i -= len(m.Fix)
		copy(dAtA[i:], m.Fix)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Fix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateFilesetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFilesetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateFilesetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FilesetId) > 0 {
		i -= len(m.FilesetId)
		copy(dAtA[i:], m.FilesetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FilesetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenewFilesetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewFilesetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewFilesetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TtlSeconds != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TtlSeconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FilesetId) > 0 {
		i -= len(m.FilesetId)
		copy(dAtA[i:], m.FilesetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FilesetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddFilesetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFilesetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddFilesetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FilesetId) > 0 {
		i -= len(m.FilesetId)
		copy(dAtA[i:], m.FilesetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FilesetId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFilesetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFilesetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFilesetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActivateAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateAuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ActivateAuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateAuthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintPfs(dAtA []byte, offset int, v uint64) int {
	offset -= sovPfs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Repo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Branch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.AuthInfo != nil {
		l = m.AuthInfo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoAuthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovPfs(uint64(e))
		}
		n += 1 + sovPfs(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BranchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Subvenance) > 0 {
		for _, e := range m.Subvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.DirectProvenance) > 0 {
		for _, e := range m.DirectProvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BranchInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.BranchInfo) > 0 {
		for _, e := range m.BranchInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Trigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.All {
		n += 2
	}
	l = len(m.CronSpec)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Size_)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Commits != 0 {
		n += 1 + sovPfs(uint64(m.Commits))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitOrigin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovPfs(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Lower != nil {
		l = m.Lower.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Upper != nil {
		l = m.Upper.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitProvenance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.ParentCommit != nil {
		l = m.ParentCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Subvenance) > 0 {
		for _, e := range m.Subvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.ChildCommits) > 0 {
		for _, e := range m.ChildCommits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.ReadyProvenance != 0 {
		n += 1 + sovPfs(uint64(m.ReadyProvenance))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 2 + l + sovPfs(uint64(l))
		}
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 2 + l + sovPfs(uint64(l))
	}
	if m.SubvenantCommitsSuccess != 0 {
		n += 2 + sovPfs(uint64(m.SubvenantCommitsSuccess))
	}
	if m.SubvenantCommitsFailure != 0 {
		n += 2 + sovPfs(uint64(m.SubvenantCommitsFailure))
	}
	if m.SubvenantCommitsTotal != 0 {
		n += 2 + sovPfs(uint64(m.SubvenantCommitsTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovPfs(uint64(m.FileType))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Committed != nil {
		l = m.Committed.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRepoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RepoInfo) > 0 {
		for _, e := range m.RepoInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.All {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FinishCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Empty {
		n += 2
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.BlockState != 0 {
		n += 1 + sovPfs(uint64(m.BlockState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPfs(uint64(m.Number))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CommitInfo) > 0 {
		for _, e := range m.CommitInfo {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SquashCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FlushCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.ToRepos) > 0 {
		for _, e := range m.ToRepos {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPfs(uint64(m.State))
	}
	if m.Prov != nil {
		l = m.Prov.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.SBranch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Overwrite {
		n += 2
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Source != nil {
		n += m.Source.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AppendFile_RawFileSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RawFileSource != nil {
		l = m.RawFileSource.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *AppendFile_TarFileSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TarFileSource != nil {
		l = m.TarFileSource.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *AppendFile_UrlFileSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UrlFileSource != nil {
		l = m.UrlFileSource.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *RawFileSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.EOF {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TarFileSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *URLFileSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Recursive {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Modification != nil {
		n += m.Modification.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyFileRequest_AppendFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppendFile != nil {
		l = m.AppendFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *ModifyFileRequest_DeleteFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteFile != nil {
		l = m.DeleteFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *CopyFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Dst != nil {
		l = m.Dst.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Overwrite {
		n += 2
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Full {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WalkFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiffFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewFile != nil {
		l = m.NewFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OldFile != nil {
		l = m.OldFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Shallow {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiffFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewFile != nil {
		l = m.NewFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OldFile != nil {
		l = m.OldFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fix {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fix)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFilesetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilesetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenewFilesetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FilesetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.TtlSeconds != 0 {
		n += 1 + sovPfs(uint64(m.TtlSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFilesetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.FilesetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetFilesetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPfs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPfs(x uint64) (n int) {
	return sovPfs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Repo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Branch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Branch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Branch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthInfo == nil {
				m.AuthInfo = &RepoAuthInfo{}
			}
			if err := m.AuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, &Branch{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoAuthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoAuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoAuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v auth.Permission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= auth.Permission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPfs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPfs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]auth.Permission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v auth.Permission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= auth.Permission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Branch{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subvenance = append(m.Subvenance, &Branch{})
			if err := m.Subvenance[len(m.Subvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectProvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectProvenance = append(m.DirectProvenance, &Branch{})
			if err := m.DirectProvenance[len(m.DirectProvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &Trigger{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BranchInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BranchInfo = append(m.BranchInfo, &BranchInfo{})
			if err := m.BranchInfo[len(m.BranchInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			m.Commits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitOrigin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitOrigin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitOrigin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= OriginKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lower == nil {
				m.Lower = &Commit{}
			}
			if err := m.Lower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upper == nil {
				m.Upper = &Commit{}
			}
			if err := m.Upper.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitProvenance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitProvenance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitProvenance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentCommit == nil {
				m.ParentCommit = &Commit{}
			}
			if err := m.ParentCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subvenance = append(m.Subvenance, &CommitRange{})
			if err := m.Subvenance[len(m.Subvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildCommits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildCommits = append(m.ChildCommits, &Commit{})
			if err := m.ChildCommits[len(m.ChildCommits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyProvenance", wireType)
			}
			m.ReadyProvenance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadyProvenance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &CommitProvenance{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &CommitOrigin{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubvenantCommitsSuccess", wireType)
			}
			m.SubvenantCommitsSuccess = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubvenantCommitsSuccess |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubvenantCommitsFailure", wireType)
			}
			m.SubvenantCommitsFailure = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubvenantCommitsFailure |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubvenantCommitsTotal", wireType)
			}
			m.SubvenantCommitsTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubvenantCommitsTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committed == nil {
				m.Committed = &types.Timestamp{}
			}
			if err := m.Committed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRepoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRepoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRepoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoInfo = append(m.RepoInfo, &RepoInfo{})
			if err := m.RepoInfo[len(m.RepoInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Commit{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &CommitProvenance{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Empty = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockState", wireType)
			}
			m.BlockState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockState |= CommitState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Commit{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitInfo = append(m.CommitInfo, &CommitInfo{})
			if err := m.CommitInfo[len(m.CommitInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SquashCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SquashCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SquashCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlushCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlushCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlushCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &Commit{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToRepos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToRepos = append(m.ToRepos, &Repo{})
			if err := m.ToRepos[len(m.ToRepos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CommitState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prov", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Prov == nil {
				m.Prov = &CommitProvenance{}
			}
			if err := m.Prov.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Branch{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &Trigger{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawFileSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RawFileSource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &AppendFile_RawFileSource{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TarFileSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TarFileSource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &AppendFile_TarFileSource{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UrlFileSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &URLFileSource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &AppendFile_UrlFileSource{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawFileSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawFileSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawFileSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EOF", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EOF = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TarFileSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TarFileSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TarFileSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *URLFileSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLFileSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLFileSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recursive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recursive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppendFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Modification = &ModifyFileRequest_AppendFile{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Modification = &ModifyFileRequest_DeleteFile{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &File{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dst == nil {
				m.Dst = &File{}
			}
			if err := m.Dst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Full", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Full = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalkFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalkFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalkFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewFile == nil {
				m.NewFile = &File{}
			}
			if err := m.NewFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldFile == nil {
				m.OldFile = &File{}
			}
			if err := m.OldFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shallow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shallow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewFile == nil {
				m.NewFile = &FileInfo{}
			}
			if err := m.NewFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldFile == nil {
				m.OldFile = &FileInfo{}
			}
			if err := m.OldFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fix = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFilesetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFilesetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFilesetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilesetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilesetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewFilesetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewFilesetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewFilesetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilesetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilesetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSeconds", wireType)
			}
			m.TtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFilesetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFilesetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFilesetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilesetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilesetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFilesetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFilesetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFilesetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPfs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPfs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPfs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPfs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPfs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPfs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPfs = fmt.Errorf("proto: unexpected end of group")
)
